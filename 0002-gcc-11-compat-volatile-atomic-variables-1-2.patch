From cc7b8b1bc5fb19e0ec5e476741c55627d4b62ba9 Mon Sep 17 00:00:00 2001
From: Robin Gareus <robin@gareus.org>
Date: Fri, 19 Mar 2021 06:12:11 +0100
Subject: [PATCH 2/3] gcc-11 compat, volatile atomic variables (1/2)

"While 'atomic' has a volatile qualifier, this is a historical
artifact and the pointer passed to it should not be volatile."

Furthermore "It is very important that all accesses to a
particular integer or pointer be performed using only this API"
(from https://developer.gnome.org/glib/2.68/glib-Atomic-Operations.html)

Hence initialization of atomic variables is changed to also use
this API, instead of directly initializing the value.

This also fixes a few cases where atomic variables were
accessed directly.

see also libs/pbd/pbd/g_atomic_compat.h
---
 libs/ardour/ardour/audio_unit.h               |  3 +-
 libs/ardour/ardour/audioengine.h              | 15 +++---
 libs/ardour/ardour/auditioner.h               |  2 +-
 libs/ardour/ardour/automation_list.h          | 12 +++--
 libs/ardour/ardour/butler.h                   | 25 +++++----
 libs/ardour/ardour/circular_buffer.h          |  6 ++-
 libs/ardour/ardour/disk_reader.h              |  8 ++-
 libs/ardour/ardour/disk_writer.h              | 15 +++---
 libs/ardour/ardour/graph.h                    | 17 +++---
 libs/ardour/ardour/graphnode.h                |  5 +-
 libs/ardour/ardour/meter.h                    |  5 +-
 libs/ardour/ardour/midi_channel_filter.h      | 12 +++--
 libs/ardour/ardour/pannable.h                 |  5 +-
 libs/ardour/ardour/playlist.h                 |  5 +-
 libs/ardour/ardour/plugin_insert.h            |  8 +--
 libs/ardour/ardour/port_engine_shared.h       |  2 +-
 libs/ardour/ardour/port_manager.h             |  3 +-
 libs/ardour/ardour/presentation_info.h        |  3 +-
 libs/ardour/ardour/route.h                    |  9 ++--
 libs/ardour/ardour/rt_tasklist.h              |  3 +-
 libs/ardour/ardour/selection.h                |  3 +-
 libs/ardour/ardour/session.h                  | 54 ++++++++++---------
 libs/ardour/ardour/source.h                   | 33 ++++++------
 libs/ardour/ardour/vst3_host.h                |  3 +-
 libs/ardour/audio_unit.cc                     |  4 +-
 libs/ardour/audioengine.cc                    | 33 ++++++------
 libs/ardour/auditioner.cc                     |  2 +-
 libs/ardour/butler.cc                         |  8 +--
 libs/ardour/disk_reader.cc                    | 13 ++---
 libs/ardour/disk_writer.cc                    | 33 ++++++------
 libs/ardour/graph.cc                          |  2 +-
 libs/ardour/graphnode.cc                      |  1 +
 libs/ardour/meter.cc                          |  5 +-
 libs/ardour/midi_channel_filter.cc            |  9 ++--
 libs/ardour/plugin_insert.cc                  |  6 +--
 libs/ardour/port_engine_shared.cc             |  2 +-
 libs/ardour/port_manager.cc                   |  2 +-
 libs/ardour/presentation_info.cc              |  6 +--
 libs/ardour/route.cc                          |  7 +--
 libs/ardour/rt_tasklist.cc                    |  4 +-
 libs/ardour/selection.cc                      |  8 +--
 libs/ardour/session.cc                        | 35 ++++++------
 libs/ardour/session_process.cc                |  4 +-
 libs/ardour/session_state.cc                  |  2 +-
 libs/ardour/session_transport.cc              |  4 +-
 libs/ardour/source.cc                         |  7 +--
 .../audiographer/general/threader.h           | 20 ++++---
 libs/backends/alsa/alsa_slave.cc              | 15 +++---
 libs/backends/alsa/alsa_slave.h               |  5 +-
 libs/evoral/Event.cc                          |  3 +-
 libs/pbd/pbd/atomic_counter.h                 | 16 +++---
 libs/pbd/pbd/g_atomic_compat.h                | 39 ++++++++++++++
 libs/pbd/pbd/mpmc_queue.h                     | 10 ++--
 libs/pbd/pbd/playback_buffer.h                | 19 +++----
 libs/pbd/pbd/rcu.h                            |  9 ++--
 libs/pbd/pbd/ringbuffer.h                     | 14 ++---
 libs/pbd/pbd/ringbufferNPT.h                  | 13 ++---
 libs/pbd/pbd/stateful.h                       |  8 +--
 libs/pbd/stateful.cc                          |  2 +-
 libs/waveview/wave_view_private.cc            |  6 +--
 libs/waveview/waveview/wave_view_private.h    |  8 +--
 61 files changed, 368 insertions(+), 272 deletions(-)
 create mode 100644 libs/pbd/pbd/g_atomic_compat.h

diff --git a/libs/ardour/ardour/audio_unit.h b/libs/ardour/ardour/audio_unit.h
index b231a9511a..96440664ed 100644
--- a/libs/ardour/ardour/audio_unit.h
+++ b/libs/ardour/ardour/audio_unit.h
@@ -31,6 +31,7 @@
 #include <vector>
 #include <map>
 
+#include "pbd/g_atomic_compat.h"
 #include "ardour/plugin.h"
 
 #include <AudioUnit/AudioUnit.h>
@@ -172,7 +173,7 @@ class LIBARDOUR_API AUPlugin : public ARDOUR::Plugin
 	int32_t output_channels;
 	std::vector<std::pair<int,int> > io_configs;
 	samplecnt_t _last_nframes;
-	mutable volatile guint _current_latency;
+	mutable GATOMIC_QUAL guint _current_latency;
 	bool _requires_fixed_size_buffers;
 	AudioBufferList* buffers;
 	bool _has_midi_input;
diff --git a/libs/ardour/ardour/audioengine.h b/libs/ardour/ardour/audioengine.h
index c2aaafae65..3913b0923d 100644
--- a/libs/ardour/ardour/audioengine.h
+++ b/libs/ardour/ardour/audioengine.h
@@ -39,6 +39,7 @@
 #include "pbd/signals.h"
 #include "pbd/pthread_utils.h"
 #include "pbd/stacktrace.h"
+#include "pbd/g_atomic_compat.h"
 
 #include "ardour/ardour.h"
 #include "ardour/data_type.h"
@@ -128,7 +129,7 @@ class LIBARDOUR_API AudioEngine : public PortManager, public SessionHandlePtr
 	bool           is_realtime() const;
 
 	// for the user which hold state_lock to check if reset operation is pending
-	bool           is_reset_requested() const { return g_atomic_int_get(const_cast<gint*>(&_hw_reset_request_count)); }
+	bool           is_reset_requested() const { return g_atomic_int_get (&_hw_reset_request_count); }
 
 	int set_device_name (const std::string&);
 	int set_sample_rate (float);
@@ -298,19 +299,19 @@ class LIBARDOUR_API AudioEngine : public PortManager, public SessionHandlePtr
 	std::string               _last_backend_error_string;
 
 	Glib::Threads::Thread*    _hw_reset_event_thread;
-	gint                      _hw_reset_request_count;
+	GATOMIC_QUAL gint         _hw_reset_request_count;
 	Glib::Threads::Cond       _hw_reset_condition;
 	Glib::Threads::Mutex      _reset_request_lock;
-	gint                      _stop_hw_reset_processing;
+	GATOMIC_QUAL gint         _stop_hw_reset_processing;
 	Glib::Threads::Thread*    _hw_devicelist_update_thread;
-	gint                      _hw_devicelist_update_count;
+	GATOMIC_QUAL gint         _hw_devicelist_update_count;
 	Glib::Threads::Cond       _hw_devicelist_update_condition;
 	Glib::Threads::Mutex      _devicelist_update_lock;
-	gint                      _stop_hw_devicelist_processing;
+	GATOMIC_QUAL gint         _stop_hw_devicelist_processing;
 	uint32_t                  _start_cnt;
 	uint32_t                  _init_countdown;
-	volatile gint             _pending_playback_latency_callback;
-	volatile gint             _pending_capture_latency_callback;
+	GATOMIC_QUAL gint         _pending_playback_latency_callback;
+	GATOMIC_QUAL gint         _pending_capture_latency_callback;
 
 	void start_hw_event_processing();
 	void stop_hw_event_processing();
diff --git a/libs/ardour/ardour/auditioner.h b/libs/ardour/ardour/auditioner.h
index c0ab20d462..54d8d08801 100644
--- a/libs/ardour/ardour/auditioner.h
+++ b/libs/ardour/ardour/auditioner.h
@@ -100,7 +100,7 @@ private:
 	boost::shared_ptr<AudioRegion> the_region;
 	boost::shared_ptr<MidiRegion> midi_region;
 	samplepos_t current_sample;
-	mutable gint _auditioning;
+	mutable GATOMIC_QUAL gint _auditioning;
 	Glib::Threads::Mutex lock;
 	samplecnt_t length;
 	sampleoffset_t _seek_sample;
diff --git a/libs/ardour/ardour/automation_list.h b/libs/ardour/ardour/automation_list.h
index c18b71d9a3..9beca77485 100644
--- a/libs/ardour/ardour/automation_list.h
+++ b/libs/ardour/ardour/automation_list.h
@@ -37,6 +37,7 @@
 #include "pbd/xml++.h"
 #include "pbd/statefuldestructible.h"
 #include "pbd/properties.h"
+#include "pbd/g_atomic_compat.h"
 
 #include "ardour/ardour.h"
 
@@ -107,9 +108,10 @@ public:
 
 	void start_touch (double when);
 	void stop_touch (double when);
-	bool touching() const { return g_atomic_int_get (const_cast<gint*>(&_touching)); }
-	bool writing() const { return _state == Write; }
-	bool touch_enabled() const { return _state & (Touch | Latch); }
+
+	bool touching () const { return g_atomic_int_get (&_touching) != 0; }
+	bool writing () const { return _state == Write; }
+	bool touch_enabled () const { return _state & (Touch | Latch); }
 
 	XMLNode& get_state ();
 	int set_state (const XMLNode &, int version);
@@ -133,8 +135,8 @@ private:
 
 	void maybe_signal_changed ();
 
-	AutoState    _state;
-	gint         _touching;
+	AutoState         _state;
+	GATOMIC_QUAL gint _touching;
 
 	PBD::ScopedConnection _writepass_connection;
 
diff --git a/libs/ardour/ardour/butler.h b/libs/ardour/ardour/butler.h
index ba3e483431..41a544f47d 100644
--- a/libs/ardour/ardour/butler.h
+++ b/libs/ardour/ardour/butler.h
@@ -30,12 +30,12 @@
 #include "pbd/crossthread.h"
 #include "pbd/ringbuffer.h"
 #include "pbd/pool.h"
+#include "pbd/g_atomic_compat.h"
+
 #include "ardour/libardour_visibility.h"
 #include "ardour/types.h"
 #include "ardour/session_handle.h"
 
-
-
 namespace ARDOUR {
 
 /**
@@ -79,15 +79,18 @@ class LIBARDOUR_API Butler : public SessionHandleRef
 		};
 	};
 
-	pthread_t    thread;
-	bool         have_thread;
-	Glib::Threads::Mutex  request_lock;
-        Glib::Threads::Cond   paused;
-	bool         should_run;
-	mutable gint should_do_transport_work;
-	samplecnt_t  _audio_capture_buffer_size;
-	samplecnt_t  _audio_playback_buffer_size;
-	uint32_t     _midi_buffer_size;
+	pthread_t thread;
+	bool      have_thread;
+
+	Glib::Threads::Mutex      request_lock;
+	Glib::Threads::Cond       paused;
+	bool                      should_run;
+	mutable GATOMIC_QUAL gint should_do_transport_work;
+
+	samplecnt_t _audio_capture_buffer_size;
+	samplecnt_t _audio_playback_buffer_size;
+	uint32_t    _midi_buffer_size;
+
 	PBD::RingBuffer<CrossThreadPool*> pool_trash;
 
 private:
diff --git a/libs/ardour/ardour/circular_buffer.h b/libs/ardour/ardour/circular_buffer.h
index 5efd9ad286..4f7a31054d 100644
--- a/libs/ardour/ardour/circular_buffer.h
+++ b/libs/ardour/ardour/circular_buffer.h
@@ -20,6 +20,7 @@
 #define _ardour_circular_buffer_h_
 
 #include "pbd/ringbuffer.h"
+#include "pbd/g_atomic_compat.h"
 
 #include "ardour/libardour_visibility.h"
 #include "ardour/types.h"
@@ -70,8 +71,9 @@ private:
 	Event* _buf;
 	guint  _size;
 	guint  _size_mask;
-	gint   _idx;
-	gint   _ack;
+
+	GATOMIC_QUAL gint _idx;
+	GATOMIC_QUAL gint _ack;
 };
 
 }
diff --git a/libs/ardour/ardour/disk_reader.h b/libs/ardour/ardour/disk_reader.h
index 97f44b348e..ccfb9b902f 100644
--- a/libs/ardour/ardour/disk_reader.h
+++ b/libs/ardour/ardour/disk_reader.h
@@ -22,6 +22,8 @@
 
 #include <boost/optional.hpp>
 
+#include "pbd/g_atomic_compat.h"
+
 #include "evoral/Curve.h"
 
 #include "ardour/disk_io.h"
@@ -196,11 +198,12 @@ private:
 	samplepos_t    overwrite_sample;
 	sampleoffset_t overwrite_offset;
 	samplepos_t    new_file_sample;
-	mutable gint   _pending_overwrite;
 	bool           run_must_resolve;
 	IOChange       input_change_pending;
 	samplepos_t    file_sample[DataType::num_types];
 
+	mutable GATOMIC_QUAL gint _pending_overwrite;
+
 	DeclickAmp            _declick_amp;
 	sampleoffset_t        _declick_offs;
 	bool                  _declick_enabled;
@@ -209,7 +212,8 @@ private:
 	boost::optional<bool> _last_read_loop;
 
 	static samplecnt_t _chunk_samples;
-	static gint        _no_disk_output;
+
+	static GATOMIC_QUAL gint _no_disk_output;
 
 	static Declicker   loop_declick_in;
 	static Declicker   loop_declick_out;
diff --git a/libs/ardour/ardour/disk_writer.h b/libs/ardour/ardour/disk_writer.h
index 3c8d23d451..578e60a56b 100644
--- a/libs/ardour/ardour/disk_writer.h
+++ b/libs/ardour/ardour/disk_writer.h
@@ -23,6 +23,8 @@
 #include <list>
 #include <vector>
 
+#include "pbd/g_atomic_compat.h"
+
 #include "ardour/disk_io.h"
 #include "ardour/midi_buffer.h"
 
@@ -83,8 +85,8 @@ public:
 
 	std::list<boost::shared_ptr<Source> >& last_capture_sources () { return _last_capture_sources; }
 
-	bool record_enabled () const { return g_atomic_int_get (const_cast<gint*> (&_record_enabled)); }
-	bool record_safe () const { return g_atomic_int_get (const_cast<gint*> (&_record_safe)); }
+	bool record_enabled () const { return g_atomic_int_get (&_record_enabled); }
+	bool record_safe () const { return g_atomic_int_get (&_record_safe); }
 
 	void set_record_enabled (bool yn);
 	void set_record_safe (bool yn);
@@ -167,8 +169,6 @@ private:
 	CaptureInfos                 capture_info;
 	mutable Glib::Threads::Mutex capture_info_lock;
 
-	gint          _record_enabled;
-	gint          _record_safe;
 	samplepos_t   _capture_start_sample;
 	samplecnt_t   _capture_captured;
 	bool          _was_recording;
@@ -180,13 +180,16 @@ private:
 	AlignStyle    _alignment_style;
 	std::string   _write_source_name;
 	NoteMode      _note_mode;
-	volatile gint _samples_pending_write;
-	volatile gint _num_captured_loops;
 	samplepos_t   _accumulated_capture_offset;
 
 	bool          _transport_looped;
 	samplepos_t   _transport_loop_sample;
 
+	GATOMIC_QUAL gint _record_enabled;
+	GATOMIC_QUAL gint _record_safe;
+	GATOMIC_QUAL gint _samples_pending_write;
+	GATOMIC_QUAL gint _num_captured_loops;
+
 	boost::shared_ptr<SMFSource> _midi_write_source;
 
 	std::list<boost::shared_ptr<Source> >            _last_capture_sources;
diff --git a/libs/ardour/ardour/graph.h b/libs/ardour/ardour/graph.h
index 2ba8ae921c..85d4ef76bc 100644
--- a/libs/ardour/ardour/graph.h
+++ b/libs/ardour/ardour/graph.h
@@ -32,6 +32,7 @@
 
 #include "pbd/mpmc_queue.h"
 #include "pbd/semutils.h"
+#include "pbd/g_atomic_compat.h"
 
 #include "ardour/audio_backend.h"
 #include "ardour/libardour_visibility.h"
@@ -91,38 +92,38 @@ private:
 	node_list_t _init_trigger_list[2];
 
 	PBD::MPMCQueue<GraphNode*> _trigger_queue;      ///< nodes that can be processed
-	volatile guint             _trigger_queue_size; ///< number of entries in trigger-queue
+	GATOMIC_QUAL guint         _trigger_queue_size; ///< number of entries in trigger-queue
 
 	/** Start worker threads */
 	PBD::Semaphore _execution_sem;
 
 	/** The number of processing threads that are asleep */
-	volatile guint _idle_thread_cnt;
+	GATOMIC_QUAL guint _idle_thread_cnt;
 
 	/** Signalled to start a run of the graph for a process callback */
 	PBD::Semaphore _callback_start_sem;
 	PBD::Semaphore _callback_done_sem;
 
 	/** The number of unprocessed nodes that do not feed any other node; updated during processing */
-	volatile guint _terminal_refcnt;
+	GATOMIC_QUAL guint _terminal_refcnt;
 
 	/** The initial number of nodes that do not feed any other node (for each chain) */
 	guint _n_terminal_nodes[2];
 	bool  _graph_empty;
 
 	/* number of background worker threads >= 0 */
-	volatile guint _n_workers;
+	GATOMIC_QUAL guint _n_workers;
 
 	/* flag to terminate background threads */
-	volatile gint _terminate;
+	GATOMIC_QUAL gint _terminate;
 
 	/* chain swapping */
 	Glib::Threads::Cond  _cleanup_cond;
 	mutable Glib::Threads::Mutex _swap_mutex;
 
-	volatile int _current_chain;
-	volatile int _pending_chain;
-	volatile int _setup_chain;
+	GATOMIC_QUAL gint _current_chain;
+	GATOMIC_QUAL gint _pending_chain;
+	GATOMIC_QUAL gint _setup_chain;
 
 	/* parameter caches */
 	pframes_t   _process_nframes;
diff --git a/libs/ardour/ardour/graphnode.h b/libs/ardour/ardour/graphnode.h
index abdfc9f2b7..05778308f7 100644
--- a/libs/ardour/ardour/graphnode.h
+++ b/libs/ardour/ardour/graphnode.h
@@ -27,6 +27,8 @@
 
 #include <boost/shared_ptr.hpp>
 
+#include "pbd/g_atomic_compat.h"
+
 namespace ARDOUR
 {
 class Graph;
@@ -68,8 +70,7 @@ private:
 	void process ();
 
 	boost::shared_ptr<Graph> _graph;
-
-	gint _refcount;
+	GATOMIC_QUAL gint        _refcount;
 };
 }
 
diff --git a/libs/ardour/ardour/meter.h b/libs/ardour/ardour/meter.h
index 73869a0ea3..f52a0658c3 100644
--- a/libs/ardour/ardour/meter.h
+++ b/libs/ardour/ardour/meter.h
@@ -25,6 +25,7 @@
 #include <vector>
 
 #include "pbd/fastlog.h"
+#include "pbd/g_atomic_compat.h"
 
 #include "ardour/libardour_visibility.h"
 #include "ardour/processor.h"
@@ -99,8 +100,8 @@ private:
 	 */
 	ChanCount current_meters;
 
-	volatile gint _reset_dpm;
-	volatile gint _reset_max;
+	GATOMIC_QUAL gint _reset_dpm;
+	GATOMIC_QUAL gint _reset_max;
 
 	uint32_t           _bufcnt;
 	std::vector<float> _peak_buffer;     // internal, integrate
diff --git a/libs/ardour/ardour/midi_channel_filter.h b/libs/ardour/ardour/midi_channel_filter.h
index 9551e71ea7..db2dac16b3 100644
--- a/libs/ardour/ardour/midi_channel_filter.h
+++ b/libs/ardour/ardour/midi_channel_filter.h
@@ -23,8 +23,10 @@
 
 #include <glib.h>
 
-#include "ardour/types.h"
 #include "pbd/signals.h"
+#include "pbd/g_atomic_compat.h"
+
+#include "ardour/types.h"
 
 namespace ARDOUR
 {
@@ -71,24 +73,24 @@ public:
 
 	/** Atomically get both the channel mode and mask. */
 	void get_mode_and_mask(ChannelMode* mode, uint16_t* mask) const {
-		const uint32_t mm = g_atomic_int_get(&_mode_mask);
+		const uint32_t mm = g_atomic_int_get (&_mode_mask);
 		*mode = static_cast<ChannelMode>((mm & 0xFFFF0000) >> 16);
 		*mask = (mm & 0x0000FFFF);
 	}
 
 	ChannelMode get_channel_mode() const {
-		return static_cast<ChannelMode>((g_atomic_int_get(&_mode_mask) & 0xFFFF0000) >> 16);
+		return static_cast<ChannelMode>((g_atomic_int_get (&_mode_mask) & 0xFFFF0000) >> 16);
 	}
 
 	uint16_t get_channel_mask() const {
-		return g_atomic_int_get(&_mode_mask) & 0x0000FFFF;
+		return g_atomic_int_get (&_mode_mask) & 0x0000FFFF;
 	}
 
 	PBD::Signal0<void> ChannelMaskChanged;
 	PBD::Signal0<void> ChannelModeChanged;
 
 private:
-	uint32_t _mode_mask;  ///< 16 bits mode, 16 bits mask
+	GATOMIC_QUAL uint32_t _mode_mask;  ///< 16 bits mode, 16 bits mask
 };
 
 } /* namespace ARDOUR */
diff --git a/libs/ardour/ardour/pannable.h b/libs/ardour/ardour/pannable.h
index 6885675b17..9aff50d118 100644
--- a/libs/ardour/ardour/pannable.h
+++ b/libs/ardour/ardour/pannable.h
@@ -66,7 +66,7 @@ public:
 
 	void start_touch (double when);
 	void stop_touch (double when);
-	bool touching() const { return g_atomic_int_get (const_cast<gint*>(&_touching)); }
+	bool touching() const { return g_atomic_int_get (&_touching); }
 	bool writing() const { return _auto_state == Write; }
 	bool touch_enabled() const { return _auto_state & (Touch | Latch); }
 
@@ -80,10 +80,11 @@ protected:
 
 	boost::weak_ptr<Panner> _panner;
 	AutoState _auto_state;
-	gint      _touching;
 	bool      _has_state;
 	uint32_t  _responding_to_control_auto_state_change;
 
+	GATOMIC_QUAL gint _touching;
+
 	void control_auto_state_changed (AutoState);
 
 private:
diff --git a/libs/ardour/ardour/playlist.h b/libs/ardour/ardour/playlist.h
index b6241cdc51..ebc15cb28e 100644
--- a/libs/ardour/ardour/playlist.h
+++ b/libs/ardour/ardour/playlist.h
@@ -45,6 +45,7 @@
 #include "pbd/stateful.h"
 #include "pbd/statefuldestructible.h"
 #include "pbd/undo.h"
+#include "pbd/g_atomic_compat.h"
 
 #include "evoral/Range.h"
 
@@ -343,8 +344,8 @@ protected:
 	PBD::ScopedConnectionList            region_drop_references_connections;
 	DataType                             _type;
 	uint32_t                             _sort_id;
-	mutable gint                         block_notifications;
-	mutable gint                         ignore_state_changes;
+	mutable GATOMIC_QUAL gint            block_notifications;
+	mutable GATOMIC_QUAL gint            ignore_state_changes;
 	std::set<boost::shared_ptr<Region> > pending_adds;
 	std::set<boost::shared_ptr<Region> > pending_removes;
 	RegionList                           pending_bounds;
diff --git a/libs/ardour/ardour/plugin_insert.h b/libs/ardour/ardour/plugin_insert.h
index 097c8e80ce..8b4b55f6e4 100644
--- a/libs/ardour/ardour/plugin_insert.h
+++ b/libs/ardour/ardour/plugin_insert.h
@@ -31,6 +31,7 @@
 
 #include "pbd/stack_allocator.h"
 #include "pbd/timing.h"
+#include "pbd/g_atomic_compat.h"
 
 #include "ardour/ardour.h"
 #include "ardour/libardour_visibility.h"
@@ -441,10 +442,9 @@ private:
 
 	void preset_load_set_value (uint32_t, float);
 
-	PBD::TimingStats _timing_stats;
-	volatile gint _stat_reset;
-
-	volatile gint _flush;
+	PBD::TimingStats  _timing_stats;
+	GATOMIC_QUAL gint _stat_reset;
+	GATOMIC_QUAL gint _flush;
 };
 
 } // namespace ARDOUR
diff --git a/libs/ardour/ardour/port_engine_shared.h b/libs/ardour/ardour/port_engine_shared.h
index 00c8b88ac0..4fbde2ba5b 100644
--- a/libs/ardour/ardour/port_engine_shared.h
+++ b/libs/ardour/ardour/port_engine_shared.h
@@ -184,7 +184,7 @@ protected:
 	std::vector<PortConnectData *> _port_connection_queue;
 	pthread_mutex_t _port_callback_mutex;
 
-	gint _port_change_flag; /* atomic */
+	GATOMIC_QUAL gint _port_change_flag; /* atomic */
 
 	void port_connect_callback (const std::string& a, const std::string& b, bool conn) {
 		pthread_mutex_lock (&_port_callback_mutex);
diff --git a/libs/ardour/ardour/port_manager.h b/libs/ardour/ardour/port_manager.h
index c2131c630b..c89ca697a1 100644
--- a/libs/ardour/ardour/port_manager.h
+++ b/libs/ardour/ardour/port_manager.h
@@ -32,6 +32,7 @@
 #include "pbd/natsort.h"
 #include "pbd/rcu.h"
 #include "pbd/ringbuffer.h"
+#include "pbd/g_atomic_compat.h"
 
 #include "ardour/chan_count.h"
 #include "ardour/midiport_manager.h"
@@ -369,7 +370,7 @@ private:
 
 	SerializedRCUManager<AudioInputPorts> _audio_input_ports;
 	SerializedRCUManager<MIDIInputPorts>  _midi_input_ports;
-	volatile gint                         _reset_meters;
+	GATOMIC_QUAL gint                     _reset_meters;
 };
 
 } // namespace ARDOUR
diff --git a/libs/ardour/ardour/presentation_info.h b/libs/ardour/ardour/presentation_info.h
index 0904a3407f..023b947730 100644
--- a/libs/ardour/ardour/presentation_info.h
+++ b/libs/ardour/ardour/presentation_info.h
@@ -29,6 +29,7 @@
 #include "pbd/signals.h"
 #include "pbd/stateful.h"
 #include "pbd/properties.h"
+#include "pbd/g_atomic_compat.h"
 
 #include "ardour/libardour_visibility.h"
 
@@ -274,7 +275,7 @@ class LIBARDOUR_API PresentationInfo : public PBD::Stateful
 
 	static PBD::PropertyChange _pending_static_changes;
 	static Glib::Threads::Mutex static_signal_lock;
-	static int _change_signal_suspended;
+	static GATOMIC_QUAL gint   _change_signal_suspended;
 
 	static int selection_counter;
 };
diff --git a/libs/ardour/ardour/route.h b/libs/ardour/ardour/route.h
index 8680b878ce..822415353e 100644
--- a/libs/ardour/ardour/route.h
+++ b/libs/ardour/ardour/route.h
@@ -41,6 +41,7 @@
 #include "pbd/stateful.h"
 #include "pbd/controllable.h"
 #include "pbd/destructible.h"
+#include "pbd/g_atomic_compat.h"
 
 #include "ardour/ardour.h"
 #include "ardour/gain_control.h"
@@ -646,10 +647,10 @@ protected:
 		EmitRtProcessorChange = 0x04
 	};
 
-	ProcessorList  _pending_processor_order;
-	gint           _pending_process_reorder; // atomic
-	gint           _pending_listen_change; // atomic
-	gint           _pending_signals; // atomic
+	ProcessorList     _pending_processor_order;
+	GATOMIC_QUAL gint _pending_process_reorder; // atomic
+	GATOMIC_QUAL gint _pending_listen_change; // atomic
+	GATOMIC_QUAL gint _pending_signals; // atomic
 
 	MeterPoint     _meter_point;
 	MeterPoint     _pending_meter_point;
diff --git a/libs/ardour/ardour/rt_tasklist.h b/libs/ardour/ardour/rt_tasklist.h
index 28b8a58d19..2ba78e9c82 100644
--- a/libs/ardour/ardour/rt_tasklist.h
+++ b/libs/ardour/ardour/rt_tasklist.h
@@ -23,6 +23,7 @@
 #include <boost/function.hpp>
 
 #include "pbd/semutils.h"
+#include "pbd/g_atomic_compat.h"
 
 #include "ardour/libardour_visibility.h"
 #include "ardour/types.h"
@@ -44,7 +45,7 @@ public:
 	void process (TaskList const&);
 
 private:
-	gint _threads_active;
+	GATOMIC_QUAL gint      _threads_active;
 	std::vector<pthread_t> _threads;
 
 	void reset_thread_list ();
diff --git a/libs/ardour/ardour/selection.h b/libs/ardour/ardour/selection.h
index 4e4832afa4..94222f84ea 100644
--- a/libs/ardour/ardour/selection.h
+++ b/libs/ardour/ardour/selection.h
@@ -91,8 +91,9 @@ class LIBARDOUR_API CoreSelection : public PBD::Stateful {
 
   private:
 	mutable Glib::Threads::RWLock _lock;
+	GATOMIC_QUAL gint             _selection_order;
+
 	Session& session;
-	int selection_order;
 
 	struct SelectedStripable {
 		SelectedStripable (boost::shared_ptr<Stripable>, boost::shared_ptr<AutomationControl>, int);
diff --git a/libs/ardour/ardour/session.h b/libs/ardour/ardour/session.h
index 838510f403..f4e430b1a0 100644
--- a/libs/ardour/ardour/session.h
+++ b/libs/ardour/ardour/session.h
@@ -62,6 +62,7 @@
 #include "pbd/statefuldestructible.h"
 #include "pbd/signals.h"
 #include "pbd/undo.h"
+#include "pbd/g_atomic_compat.h"
 
 #include "lua/luastate.h"
 
@@ -1361,7 +1362,6 @@ private:
 	typedef void (Session::*process_function_type)(pframes_t);
 
 	AudioEngine&            _engine;
-	mutable gint             processing_prohibited;
 	process_function_type    process_function;
 	process_function_type    last_process_function;
 	bool                    _bounce_processing_active;
@@ -1369,10 +1369,9 @@ private:
 	samplecnt_t             _base_sample_rate;     // sample-rate of the session at creation time, "native" SR
 	samplecnt_t             _nominal_sample_rate;  // overridden by audioengine setting
 	samplecnt_t             _current_sample_rate;  // this includes video pullup offset
-	mutable gint            _record_status;
 	samplepos_t             _transport_sample;
-	gint                    _seek_counter;
-	gint                    _butler_seek_counter;
+	GATOMIC_QUAL gint       _seek_counter;
+	GATOMIC_QUAL gint       _butler_seek_counter;
 	Location*               _session_range_location; ///< session range, or 0 if there is nothing in the session yet
 	bool                    _session_range_is_free;
 	bool                    _silent;
@@ -1408,6 +1407,9 @@ private:
 
 	std::string             _missing_file_replacement;
 
+	mutable GATOMIC_QUAL gint _processing_prohibited;
+	mutable GATOMIC_QUAL gint _record_status;
+
 	void add_monitor_section ();
 	void remove_monitor_section ();
 
@@ -1430,9 +1432,9 @@ private:
 
 	samplecnt_t calc_preroll_subcycle (samplecnt_t) const;
 
-	void block_processing() { g_atomic_int_set (&processing_prohibited, 1); }
-	void unblock_processing() { g_atomic_int_set (&processing_prohibited, 0); }
-	bool processing_blocked() const { return g_atomic_int_get (&processing_prohibited); }
+	void block_processing() { g_atomic_int_set (&_processing_prohibited, 1); }
+	void unblock_processing() { g_atomic_int_set (&_processing_prohibited, 0); }
+	bool processing_blocked() const { return g_atomic_int_get (&_processing_prohibited); }
 
 	static const samplecnt_t bounce_chunk_size;
 
@@ -1535,9 +1537,9 @@ private:
 	StateOfTheState _state_of_the_state;
 
 	friend class    StateProtector;
-	gint            _suspend_save; /* atomic */
-	volatile bool   _save_queued;
-	volatile bool   _save_queued_pending;
+	GATOMIC_QUAL gint  _suspend_save;
+	volatile bool      _save_queued;
+	volatile bool      _save_queued_pending;
 
 	Glib::Threads::Mutex save_state_lock;
 	Glib::Threads::Mutex save_source_lock;
@@ -1576,8 +1578,8 @@ private:
 
 	static const PostTransportWork ProcessCannotProceedMask = PostTransportWork (PostTransportAudition);
 
-	gint _post_transport_work; /* accessed only atomic ops */
-	PostTransportWork post_transport_work() const        { return (PostTransportWork) g_atomic_int_get (const_cast<gint*>(&_post_transport_work)); }
+	GATOMIC_QUAL gint _post_transport_work; /* accessed only atomic ops */
+	PostTransportWork post_transport_work() const        { return (PostTransportWork) g_atomic_int_get (&_post_transport_work); }
 	void set_post_transport_work (PostTransportWork ptw) { g_atomic_int_set (&_post_transport_work, (gint) ptw); }
 	void add_post_transport_work (PostTransportWork ptw);
 
@@ -1694,9 +1696,9 @@ private:
 	Glib::Threads::Mutex  _update_latency_lock;
 
 	typedef std::queue<AutoConnectRequest> AutoConnectQueue;
-	Glib::Threads::Mutex  _auto_connect_queue_lock;
-	AutoConnectQueue _auto_connect_queue;
-	guint _latency_recompute_pending;
+	Glib::Threads::Mutex _auto_connect_queue_lock;
+	AutoConnectQueue     _auto_connect_queue;
+	GATOMIC_QUAL guint   _latency_recompute_pending;
 
 	void get_physical_ports (std::vector<std::string>& inputs, std::vector<std::string>& outputs, DataType type,
 	                         MidiPortFlags include = MidiPortFlags (0),
@@ -1817,8 +1819,8 @@ private:
 		OnlyLoop,
 	};
 
-	volatile gint _punch_or_loop; // enum PunchLoopLock
-	gint current_usecs_per_track;
+	GATOMIC_QUAL gint _punch_or_loop; // enum PunchLoopLock
+	GATOMIC_QUAL gint _current_usecs_per_track;
 
 	bool punch_active () const;
 	void unset_punch ();
@@ -2024,8 +2026,8 @@ private:
 
 	std::string get_best_session_directory_for_new_audio ();
 
-	mutable gint _playback_load;
-	mutable gint _capture_load;
+	mutable GATOMIC_QUAL gint _playback_load;
+	mutable GATOMIC_QUAL gint _capture_load;
 
 	/* I/O bundles */
 
@@ -2147,8 +2149,8 @@ private:
 	mutable bool have_looped; ///< Used in \ref audible_sample
 
 	void update_route_record_state ();
-	gint _have_rec_enabled_track;
-	gint _have_rec_disabled_track;
+	GATOMIC_QUAL gint _have_rec_enabled_track;
+	GATOMIC_QUAL gint _have_rec_disabled_track;
 
 	static int ask_about_playlist_deletion (boost::shared_ptr<Playlist>);
 
@@ -2195,7 +2197,7 @@ private:
 	uint32_t _step_editors;
 
 	/** true if timecode transmission by the transport is suspended, otherwise false */
-	mutable gint _suspend_timecode_transmission;
+	mutable GATOMIC_QUAL gint _suspend_timecode_transmission;
 
 	void update_locations_after_tempo_map_change (const Locations::LocationList &);
 
@@ -2215,9 +2217,9 @@ private:
 
 	void ensure_route_presentation_info_gap (PresentationInfo::order_t, uint32_t gap_size);
 
-	friend class    ProcessorChangeBlocker;
-	gint            _ignore_route_processor_changes; /* atomic */
-	gint            _ignored_a_processor_change;
+	friend class ProcessorChangeBlocker;
+	GATOMIC_QUAL gint _ignore_route_processor_changes;
+	GATOMIC_QUAL gint _ignored_a_processor_change;
 
 	MidiClockTicker* midi_clock;
 
@@ -2265,7 +2267,7 @@ private:
 
 	std::string unnamed_file_name () const;
 
-	gint _update_pretty_names;
+	GATOMIC_QUAL gint _update_pretty_names;
 };
 
 
diff --git a/libs/ardour/ardour/source.h b/libs/ardour/ardour/source.h
index 1381d5bfdc..2049c638f6 100644
--- a/libs/ardour/ardour/source.h
+++ b/libs/ardour/ardour/source.h
@@ -31,7 +31,9 @@
 #include <boost/shared_ptr.hpp>
 #include <boost/enable_shared_from_this.hpp>
 #include <boost/utility.hpp>
+
 #include "pbd/statefuldestructible.h"
+#include "pbd/g_atomic_compat.h"
 
 #include "ardour/ardour.h"
 #include "ardour/session_object.h"
@@ -121,7 +123,7 @@ public:
 
 	virtual void inc_use_count ();
 	virtual void dec_use_count ();
-	int  use_count() const { return g_atomic_int_get (const_cast<gint*>(&_use_count)); }
+	int  use_count() const { return g_atomic_int_get (&_use_count); }
 	bool used() const { return use_count() > 0; }
 
 	uint32_t level() const { return _level; }
@@ -135,20 +137,21 @@ public:
 	static PBD::Signal1<void,boost::shared_ptr<ARDOUR::Source> > SourcePropertyChanged;
 
   protected:
-	DataType            _type;
-	Flag                _flags;
-	time_t              _timestamp;
-	std::string         _take_id;
-	samplepos_t          _natural_position;
-	samplepos_t          _have_natural_position;
-	bool                _analysed;
-        mutable Glib::Threads::Mutex _lock;
-        mutable Glib::Threads::Mutex _analysis_lock;
-	gint                _use_count; /* atomic */
-	uint32_t            _level; /* how deeply nested is this source w.r.t a disk file */
-	std::string         _ancestor_name;
-	std::string        _captured_for;
-	XrunPositions      _xruns;
+	DataType          _type;
+	Flag              _flags;
+	time_t            _timestamp;
+	std::string       _take_id;
+	samplepos_t       _natural_position;
+	samplepos_t       _have_natural_position;
+	bool              _analysed;
+	GATOMIC_QUAL gint _use_count; /* atomic */
+	uint32_t          _level; /* how deeply nested is this source w.r.t a disk file */
+	std::string       _ancestor_name;
+	std::string       _captured_for;
+	XrunPositions     _xruns;
+
+	mutable Glib::Threads::Mutex _lock;
+	mutable Glib::Threads::Mutex _analysis_lock;
 
   private:
 	void fix_writable_flags ();
diff --git a/libs/ardour/ardour/vst3_host.h b/libs/ardour/ardour/vst3_host.h
index 10e283752b..12856bb226 100644
--- a/libs/ardour/ardour/vst3_host.h
+++ b/libs/ardour/ardour/vst3_host.h
@@ -28,6 +28,7 @@
 
 #include <boost/shared_ptr.hpp>
 
+#include "pbd/g_atomic_compat.h"
 #include "ardour/libardour_visibility.h"
 #include "vst3/vst3.h"
 
@@ -151,7 +152,7 @@ public:
 	uint32 PLUGIN_API release () SMTG_OVERRIDE;
 
 private:
-	gint _cnt; // atomic
+	GATOMIC_QUAL gint _cnt; // atomic
 };
 
 class LIBARDOUR_API HostAttributeList : public Vst::IAttributeList, public RefObject
diff --git a/libs/ardour/audio_unit.cc b/libs/ardour/audio_unit.cc
index 986f67f435..c5d70ffe7f 100644
--- a/libs/ardour/audio_unit.cc
+++ b/libs/ardour/audio_unit.cc
@@ -435,7 +435,6 @@ AUPlugin::AUPlugin (AudioEngine& engine, Session& session, boost::shared_ptr<CAC
 	, unit (new CAAudioUnit)
 	, initialized (false)
 	, _last_nframes (0)
-	, _current_latency (UINT_MAX)
 	, _requires_fixed_size_buffers (false)
 	, buffers (0)
 	, variable_inputs (false)
@@ -477,7 +476,6 @@ AUPlugin::AUPlugin (const AUPlugin& other)
 	, unit (new CAAudioUnit)
 	, initialized (false)
 	, _last_nframes (0)
-	, _current_latency (UINT_MAX)
 	, _requires_fixed_size_buffers (false)
 	, buffers (0)
 	, variable_inputs (false)
@@ -571,6 +569,8 @@ AUPlugin::discover_factory_presets ()
 void
 AUPlugin::init ()
 {
+	g_atomic_int_set (&_current_latency, UINT_MAX);
+
 	OSErr err;
 	CFStringRef itemName;
 
diff --git a/libs/ardour/audioengine.cc b/libs/ardour/audioengine.cc
index b0c8ae6d6d..b9ce4476b0 100644
--- a/libs/ardour/audioengine.cc
+++ b/libs/ardour/audioengine.cc
@@ -73,7 +73,7 @@ using namespace PBD;
 
 AudioEngine* AudioEngine::_instance = 0;
 
-static gint audioengine_thread_cnt = 1;
+static GATOMIC_QUAL gint audioengine_thread_cnt = 1;
 
 #ifdef SILENCE_AFTER
 #define SILENCE_AFTER_SECONDS 600
@@ -99,15 +99,9 @@ AudioEngine::AudioEngine ()
 	, _in_destructor (false)
 	, _last_backend_error_string(AudioBackend::get_error_string(AudioBackend::NoError))
 	, _hw_reset_event_thread(0)
-	, _hw_reset_request_count(0)
-	, _stop_hw_reset_processing(0)
 	, _hw_devicelist_update_thread(0)
-	, _hw_devicelist_update_count(0)
-	, _stop_hw_devicelist_processing(0)
 	, _start_cnt (0)
 	, _init_countdown (0)
-	, _pending_playback_latency_callback (0)
-	, _pending_capture_latency_callback (0)
 #ifdef SILENCE_AFTER_SECONDS
 	, _silence_countdown (0)
 	, _silence_hit_cnt (0)
@@ -116,6 +110,13 @@ AudioEngine::AudioEngine ()
 	reset_silence_countdown ();
 	start_hw_event_processing();
 	discover_backends ();
+
+	g_atomic_int_set (&_hw_reset_request_count, 0);
+	g_atomic_int_set (&_pending_playback_latency_callback, 0);
+	g_atomic_int_set (&_pending_capture_latency_callback, 0);
+	g_atomic_int_set (&_hw_devicelist_update_count, 0);
+	g_atomic_int_set (&_stop_hw_reset_processing, 0);
+	g_atomic_int_set (&_stop_hw_devicelist_processing, 0);
 }
 
 AudioEngine::~AudioEngine ()
@@ -639,7 +640,7 @@ AudioEngine::do_reset_backend()
 
 	Glib::Threads::Mutex::Lock guard (_reset_request_lock);
 
-	while (!_stop_hw_reset_processing) {
+	while (!g_atomic_int_get (&_stop_hw_reset_processing)) {
 
 		if (g_atomic_int_get (&_hw_reset_request_count) != 0 && _backend) {
 
@@ -724,14 +725,14 @@ void
 AudioEngine::start_hw_event_processing()
 {
 	if (_hw_reset_event_thread == 0) {
-		g_atomic_int_set(&_hw_reset_request_count, 0);
-		g_atomic_int_set(&_stop_hw_reset_processing, 0);
+		g_atomic_int_set (&_hw_reset_request_count, 0);
+		g_atomic_int_set (&_stop_hw_reset_processing, 0);
 		_hw_reset_event_thread = Glib::Threads::Thread::create (boost::bind (&AudioEngine::do_reset_backend, this));
 	}
 
 	if (_hw_devicelist_update_thread == 0) {
-		g_atomic_int_set(&_hw_devicelist_update_count, 0);
-		g_atomic_int_set(&_stop_hw_devicelist_processing, 0);
+		g_atomic_int_set (&_hw_devicelist_update_count, 0);
+		g_atomic_int_set (&_stop_hw_devicelist_processing, 0);
 		_hw_devicelist_update_thread = Glib::Threads::Thread::create (boost::bind (&AudioEngine::do_devicelist_update, this));
 	}
 }
@@ -741,16 +742,16 @@ void
 AudioEngine::stop_hw_event_processing()
 {
 	if (_hw_reset_event_thread) {
-		g_atomic_int_set(&_stop_hw_reset_processing, 1);
-		g_atomic_int_set(&_hw_reset_request_count, 0);
+		g_atomic_int_set (&_stop_hw_reset_processing, 1);
+		g_atomic_int_set (&_hw_reset_request_count, 0);
 		_hw_reset_condition.signal ();
 		_hw_reset_event_thread->join ();
 		_hw_reset_event_thread = 0;
 	}
 
 	if (_hw_devicelist_update_thread) {
-		g_atomic_int_set(&_stop_hw_devicelist_processing, 1);
-		g_atomic_int_set(&_hw_devicelist_update_count, 0);
+		g_atomic_int_set (&_stop_hw_devicelist_processing, 1);
+		g_atomic_int_set (&_hw_devicelist_update_count, 0);
 		_hw_devicelist_update_condition.signal ();
 		_hw_devicelist_update_thread->join ();
 		_hw_devicelist_update_thread = 0;
diff --git a/libs/ardour/auditioner.cc b/libs/ardour/auditioner.cc
index 6e8cdeb58a..04cf37926a 100644
--- a/libs/ardour/auditioner.cc
+++ b/libs/ardour/auditioner.cc
@@ -51,7 +51,6 @@ using namespace PBD;
 Auditioner::Auditioner (Session& s)
 	: Track (s, "auditioner", PresentationInfo::Auditioner)
 	, current_sample (0)
-	, _auditioning (0)
 	, length (0)
 	, _seek_sample (-1)
 	, _seeking (false)
@@ -61,6 +60,7 @@ Auditioner::Auditioner (Session& s)
 	, _queue_panic (false)
 	, _import_position (0)
 {
+	g_atomic_int_set (&_auditioning, 0);
 }
 
 int
diff --git a/libs/ardour/butler.cc b/libs/ardour/butler.cc
index 935dccc361..4a154fd94f 100644
--- a/libs/ardour/butler.cc
+++ b/libs/ardour/butler.cc
@@ -56,11 +56,11 @@ Butler::Butler(Session& s)
 	, pool_trash(16)
 	, _xthread (true)
 {
-	g_atomic_int_set(&should_do_transport_work, 0);
+	g_atomic_int_set (&should_do_transport_work, 0);
 	SessionEvent::pool->set_trash (&pool_trash);
 
-        /* catch future changes to parameters */
-        Config->ParameterChanged.connect_same_thread (*this, boost::bind (&Butler::config_changed, this, _1));
+	/* catch future changes to parameters */
+	Config->ParameterChanged.connect_same_thread (*this, boost::bind (&Butler::config_changed, this, _1));
 }
 
 Butler::~Butler()
@@ -466,7 +466,7 @@ Butler::wait_until_finished ()
 bool
 Butler::transport_work_requested () const
 {
-	return g_atomic_int_get(&should_do_transport_work);
+	return g_atomic_int_get (&should_do_transport_work);
 }
 
 void
diff --git a/libs/ardour/disk_reader.cc b/libs/ardour/disk_reader.cc
index 899a65a33c..d90ec3b546 100644
--- a/libs/ardour/disk_reader.cc
+++ b/libs/ardour/disk_reader.cc
@@ -52,7 +52,7 @@ PBD::Signal0<void>    DiskReader::Underrun;
 Sample*               DiskReader::_sum_buffer     = 0;
 Sample*               DiskReader::_mixdown_buffer = 0;
 gain_t*               DiskReader::_gain_buffer    = 0;
-gint                  DiskReader::_no_disk_output (0);
+GATOMIC_QUAL gint     DiskReader::_no_disk_output (0);
 DiskReader::Declicker DiskReader::loop_declick_in;
 DiskReader::Declicker DiskReader::loop_declick_out;
 samplecnt_t           DiskReader::loop_fade_length (0);
@@ -275,6 +275,7 @@ DiskReader::run (BufferSet& bufs, samplepos_t start_sample, samplepos_t end_samp
 	sampleoffset_t                 disk_samples_to_consume;
 	MonitorState                   ms = _track.monitoring_state ();
 	const bool                     midi_only = (c->empty() || !_playlists[DataType::AUDIO]);
+	bool                           no_disk_output = g_atomic_int_get (&_no_disk_output) != 0;
 
 	if (_active) {
 		if (!_pending_active) {
@@ -358,10 +359,10 @@ DiskReader::run (BufferSet& bufs, samplepos_t start_sample, samplepos_t end_samp
 		_declick_offs = 0;
 	}
 
-	if (!result_required || ((ms & MonitoringDisk) == 0) || still_locating || _no_disk_output) {
+	if (!result_required || ((ms & MonitoringDisk) == 0) || still_locating || no_disk_output) {
 		/* no need for actual disk data, just advance read pointer */
 
-		if (!still_locating || _no_disk_output) {
+		if (!still_locating || no_disk_output) {
 			for (ChannelList::iterator chan = c->begin (); chan != c->end (); ++chan) {
 				assert ((*chan)->rbuf);
 				(*chan)->rbuf->increment_read_ptr (disk_samples_to_consume);
@@ -370,7 +371,7 @@ DiskReader::run (BufferSet& bufs, samplepos_t start_sample, samplepos_t end_samp
 
 		/* if monitoring disk but locating put silence in the buffers */
 
-		if ((_no_disk_output || still_locating) && (ms == MonitoringDisk)) {
+		if ((no_disk_output || still_locating) && (ms == MonitoringDisk)) {
 			bufs.silence (nframes, 0);
 		}
 
@@ -473,7 +474,7 @@ midi:
 			run_must_resolve = false;
 		}
 
-		if (!_no_disk_output && !declick_in_progress () && (ms & MonitoringDisk) && !still_locating && no_playlist_modification_pending && speed) {
+		if (!no_disk_output && !declick_in_progress () && (ms & MonitoringDisk) && !still_locating && no_playlist_modification_pending && speed) {
 			get_midi_playback (dst, start_sample, end_sample, ms, scratch_bufs, speed, disk_samples_to_consume);
 		}
 	}
@@ -1468,7 +1469,7 @@ DiskReader::get_midi_playback (MidiBuffer& dst, samplepos_t start_sample, sample
 		target = &dst;
 	}
 
-	if (!_no_disk_output) {
+	if (!g_atomic_int_get (&_no_disk_output)) {
 		const samplecnt_t nframes = abs (end_sample - start_sample);
 
 		if (ms & MonitoringDisk) {
diff --git a/libs/ardour/disk_writer.cc b/libs/ardour/disk_writer.cc
index 86961a4112..5e64745243 100644
--- a/libs/ardour/disk_writer.cc
+++ b/libs/ardour/disk_writer.cc
@@ -48,8 +48,6 @@ PBD::Signal0<void> DiskWriter::Overrun;
 
 DiskWriter::DiskWriter (Session& s, Track& t, string const & str, DiskIOProcessor::Flag f)
 	: DiskIOProcessor (s, t, X_("recorder:") + str, f)
-	, _record_enabled (0)
-	, _record_safe (0)
 	, _capture_start_sample (0)
 	, _capture_captured (0)
 	, _was_recording (false)
@@ -59,8 +57,6 @@ DiskWriter::DiskWriter (Session& s, Track& t, string const & str, DiskIOProcesso
 	, _last_possibly_recording (0)
 	, _alignment_style (ExistingMaterial)
 	, _note_mode (Sustained)
-	, _samples_pending_write (0)
-	, _num_captured_loops (0)
 	, _accumulated_capture_offset (0)
 	, _transport_looped (false)
 	, _transport_loop_sample (0)
@@ -68,6 +64,11 @@ DiskWriter::DiskWriter (Session& s, Track& t, string const & str, DiskIOProcesso
 {
 	DiskIOProcessor::init ();
 	_xruns.reserve (128);
+
+	g_atomic_int_set (&_record_enabled, 0);
+	g_atomic_int_set (&_record_safe, 0);
+	g_atomic_int_set (&_samples_pending_write, 0);
+	g_atomic_int_set (&_num_captured_loops, 0);
 }
 
 DiskWriter::~DiskWriter ()
@@ -337,7 +338,7 @@ DiskWriter::state ()
 {
 	XMLNode& node (DiskIOProcessor::state ());
 	node.set_property (X_("type"), X_("diskwriter"));
-	node.set_property (X_("record-safe"), (_record_safe ? X_("yes" : "no")));
+	node.set_property (X_("record-safe"), record_safe ());
 	return node;
 }
 
@@ -348,9 +349,9 @@ DiskWriter::set_state (const XMLNode& node, int version)
 		return -1;
 	}
 
-	if (!node.get_property (X_("record-safe"), _record_safe)) {
-		_record_safe = false;
-	}
+	int rec_safe = 0;
+	node.get_property (X_("record-safe"), rec_safe);
+	g_atomic_int_set (&_record_safe, rec_safe);
 
 	reset_write_sources (false, true);
 
@@ -490,8 +491,8 @@ DiskWriter::run (BufferSet& bufs, samplepos_t start_sample, samplepos_t end_samp
 				_midi_write_source->mark_write_starting_now (_capture_start_sample, _capture_captured, loop_length);
 			}
 
-			g_atomic_int_set (const_cast<gint*> (&_samples_pending_write), 0);
-			g_atomic_int_set (const_cast<gint*> (&_num_captured_loops), 0);
+			g_atomic_int_set (&_samples_pending_write, 0);
+			g_atomic_int_set (&_num_captured_loops, 0);
 
 			_was_recording = true;
 
@@ -595,7 +596,7 @@ DiskWriter::run (BufferSet& bufs, samplepos_t start_sample, samplepos_t end_samp
 				   reconstruct their actual time; future clever MIDI looping should
 				   probably be implemented in the source instead of here.
 				*/
-				const samplecnt_t loop_offset = _num_captured_loops * loop_length;
+				const samplecnt_t loop_offset = g_atomic_int_get (&_num_captured_loops) * loop_length;
 				const samplepos_t event_time = start_sample + loop_offset - _accumulated_capture_offset + ev.time();
 				if (event_time < 0 || event_time < _first_recordable_sample) {
 					/* Event out of range, skip */
@@ -621,7 +622,7 @@ DiskWriter::run (BufferSet& bufs, samplepos_t start_sample, samplepos_t end_samp
 				}
 			}
 
-			g_atomic_int_add (const_cast<gint*>(&_samples_pending_write), nframes);
+			g_atomic_int_add (&_samples_pending_write, nframes);
 
 			if (buf.size() != 0) {
 				Glib::Threads::Mutex::Lock lm (_gui_feed_buffer_mutex, Glib::Threads::TRY_LOCK);
@@ -707,7 +708,7 @@ DiskWriter::finish_capture (boost::shared_ptr<ChannelList> c)
 		samplepos_t loop_end    = 0;
 		samplepos_t loop_length = 0;
 		get_location_times (_loop_location, &loop_start, &loop_end, &loop_length);
-		ci->loop_offset = _num_captured_loops * loop_length;
+		ci->loop_offset = g_atomic_int_get (&_num_captured_loops) * loop_length;
 	} else {
 		ci->loop_offset = 0;
 	}
@@ -945,7 +946,7 @@ DiskWriter::do_flush (RunContext ctxt, bool force_flush)
 
 	if (_midi_write_source && _midi_buf) {
 
-		const samplecnt_t total = g_atomic_int_get(const_cast<gint*> (&_samples_pending_write));
+		const samplecnt_t total = g_atomic_int_get(&_samples_pending_write);
 
 		if (total == 0 ||
 		    _midi_buf->read_space() == 0 ||
@@ -981,7 +982,7 @@ DiskWriter::do_flush (RunContext ctxt, bool force_flush)
 				error << string_compose(_("MidiDiskstream %1: cannot write to disk"), id()) << endmsg;
 				return -1;
 			}
-			g_atomic_int_add(const_cast<gint*> (&_samples_pending_write), -to_write);
+			g_atomic_int_add(&_samples_pending_write, -to_write);
 		}
 	}
 
@@ -1300,7 +1301,7 @@ DiskWriter::loop (samplepos_t transport_sample)
 	   the Source and/or entirely after the capture is finished.
 	*/
 	if (_was_recording) {
-		g_atomic_int_add(const_cast<gint*> (&_num_captured_loops), 1);
+		g_atomic_int_add (&_num_captured_loops, 1);
 	}
 }
 
diff --git a/libs/ardour/graph.cc b/libs/ardour/graph.cc
index f5466d7d87..c815dd53e6 100644
--- a/libs/ardour/graph.cc
+++ b/libs/ardour/graph.cc
@@ -420,7 +420,7 @@ Graph::run_one ()
 	while (!to_run) {
 		/* Wait for work, fall asleep */
 		g_atomic_int_inc (&_idle_thread_cnt);
-		assert (g_atomic_uint_get (&_idle_thread_cnt) <= _n_workers);
+		assert (g_atomic_uint_get (&_idle_thread_cnt) <= g_atomic_uint_get (&_n_workers));
 
 		DEBUG_TRACE (DEBUG::ProcessThreads, string_compose ("%1 goes to sleep\n", pthread_name ()));
 		_execution_sem.wait ();
diff --git a/libs/ardour/graphnode.cc b/libs/ardour/graphnode.cc
index 7115b931d8..a310f0a14f 100644
--- a/libs/ardour/graphnode.cc
+++ b/libs/ardour/graphnode.cc
@@ -27,6 +27,7 @@ using namespace ARDOUR;
 GraphNode::GraphNode (boost::shared_ptr<Graph> graph)
 	: _graph (graph)
 {
+	g_atomic_int_set (&_refcount, 0);
 }
 
 GraphNode::~GraphNode ()
diff --git a/libs/ardour/meter.cc b/libs/ardour/meter.cc
index b302541076..0329365569 100644
--- a/libs/ardour/meter.cc
+++ b/libs/ardour/meter.cc
@@ -51,10 +51,11 @@ PeakMeter::PeakMeter (Session& s, const std::string& name)
 
 	_pending_active = true;
 	_meter_type     = MeterPeak;
-	_reset_dpm      = 1;
-	_reset_max      = 1;
 	_bufcnt         = 0;
 	_combined_peak  = 0;
+
+	g_atomic_int_set (&_reset_dpm, 1);
+	g_atomic_int_set (&_reset_max, 1);
 }
 
 PeakMeter::~PeakMeter ()
diff --git a/libs/ardour/midi_channel_filter.cc b/libs/ardour/midi_channel_filter.cc
index 953a69a2c9..e570744fe1 100644
--- a/libs/ardour/midi_channel_filter.cc
+++ b/libs/ardour/midi_channel_filter.cc
@@ -24,8 +24,9 @@
 namespace ARDOUR {
 
 MidiChannelFilter::MidiChannelFilter()
-	: _mode_mask(0x0000FFFF)
-{}
+{
+	g_atomic_int_set (&_mode_mask, 0x0000FFFF);
+}
 
 void
 MidiChannelFilter::filter(BufferSet& bufs)
@@ -114,7 +115,7 @@ MidiChannelFilter::set_channel_mode(ChannelMode mode, uint16_t mask)
 
 	if (old_mode != mode || old_mask != mask) {
 		mask = force_mask(mode, mask);
-		g_atomic_int_set(&_mode_mask, (uint32_t(mode) << 16) | uint32_t(mask));
+		g_atomic_int_set (&_mode_mask, (uint32_t(mode) << 16) | uint32_t(mask));
 		ChannelModeChanged();
 		return true;
 	}
@@ -131,7 +132,7 @@ MidiChannelFilter::set_channel_mask(uint16_t mask)
 
 	if (old_mask != mask) {
 		mask = force_mask(mode, mask);
-		g_atomic_int_set(&_mode_mask, (uint32_t(mode) << 16) | uint32_t(mask));
+		g_atomic_int_set (&_mode_mask, (uint32_t(mode) << 16) | uint32_t(mask));
 		ChannelMaskChanged();
 		return true;
 	}
diff --git a/libs/ardour/plugin_insert.cc b/libs/ardour/plugin_insert.cc
index ebb777da2d..b0048bbd01 100644
--- a/libs/ardour/plugin_insert.cc
+++ b/libs/ardour/plugin_insert.cc
@@ -90,11 +90,11 @@ PluginInsert::PluginInsert (Session& s, boost::shared_ptr<Plugin> plug)
 	, _latency_changed (false)
 	, _bypass_port (UINT32_MAX)
 	, _inverted_bypass_enable (false)
-	, _stat_reset (0)
-	, _flush (0)
 {
-	/* the first is the master */
+	g_atomic_int_set (&_stat_reset, 0);
+	g_atomic_int_set (&_flush, 0);
 
+	/* the first is the master */
 	if (plug) {
 		add_plugin (plug);
 		create_automatable_parameters ();
diff --git a/libs/ardour/port_engine_shared.cc b/libs/ardour/port_engine_shared.cc
index c9937c7f61..cac716b607 100644
--- a/libs/ardour/port_engine_shared.cc
+++ b/libs/ardour/port_engine_shared.cc
@@ -190,10 +190,10 @@ BackendPort::update_connected_latency (bool for_playback)
 
 PortEngineSharedImpl::PortEngineSharedImpl (PortManager& mgr, std::string const & str)
 	: _instance_name (str)
-	, _port_change_flag (0)
 	, _portmap (new PortMap)
 	, _ports (new PortIndex)
 {
+	g_atomic_int_set (&_port_change_flag, 0);
 	pthread_mutex_init (&_port_callback_mutex, 0);
 }
 
diff --git a/libs/ardour/port_manager.cc b/libs/ardour/port_manager.cc
index 523bd00b12..9c512e911c 100644
--- a/libs/ardour/port_manager.cc
+++ b/libs/ardour/port_manager.cc
@@ -144,8 +144,8 @@ PortManager::PortManager ()
 	, _midi_info_dirty (true)
 	, _audio_input_ports (new AudioInputPorts)
 	, _midi_input_ports (new MIDIInputPorts)
-	, _reset_meters (0)
 {
+	g_atomic_int_set (&_reset_meters, 1);
 	load_port_info ();
 }
 
diff --git a/libs/ardour/presentation_info.cc b/libs/ardour/presentation_info.cc
index ddbfb258ef..1f16b33168 100644
--- a/libs/ardour/presentation_info.cc
+++ b/libs/ardour/presentation_info.cc
@@ -48,7 +48,7 @@ string PresentationInfo::state_node_name = X_("PresentationInfo");
 
 PBD::Signal1<void,PropertyChange const &> PresentationInfo::Change;
 Glib::Threads::Mutex PresentationInfo::static_signal_lock;
-int PresentationInfo::_change_signal_suspended = 0;
+GATOMIC_QUAL gint PresentationInfo::_change_signal_suspended = 0;
 PBD::PropertyChange PresentationInfo::_pending_static_changes;
 int PresentationInfo::selection_counter= 0;
 
@@ -71,7 +71,7 @@ PresentationInfo::unsuspend_change_signal ()
 {
 	Glib::Threads::Mutex::Lock lm (static_signal_lock);
 
-	if (g_atomic_int_get (const_cast<gint*> (&_change_signal_suspended)) == 1) {
+	if (g_atomic_int_get (&_change_signal_suspended) == 1) {
 
 		/* atomically grab currently pending flags */
 
@@ -93,7 +93,7 @@ PresentationInfo::unsuspend_change_signal ()
 		}
 	}
 
-	g_atomic_int_add (const_cast<gint*>(&_change_signal_suspended), -1);
+	g_atomic_int_add (&_change_signal_suspended, -1);
 }
 
 void
diff --git a/libs/ardour/route.cc b/libs/ardour/route.cc
index 0ee56879ab..8661ca89b0 100644
--- a/libs/ardour/route.cc
+++ b/libs/ardour/route.cc
@@ -115,9 +115,6 @@ Route::Route (Session& sess, string name, PresentationInfo::Flag flag, DataType
 	, _active (true)
 	, _signal_latency (0)
 	, _disk_io_point (DiskIOPreFader)
-	, _pending_process_reorder (0)
-	, _pending_listen_change (0)
-	, _pending_signals (0)
 	, _meter_point (MeterPostFader)
 	, _pending_meter_point (MeterPostFader)
 	, _denormal_protection (false)
@@ -138,6 +135,10 @@ Route::Route (Session& sess, string name, PresentationInfo::Flag flag, DataType
 	, _patch_selector_dialog (0)
 {
 	processor_max_streams.reset();
+
+	g_atomic_int_set (&_pending_process_reorder, 0);
+	g_atomic_int_set (&_pending_listen_change, 0);
+	g_atomic_int_set (&_pending_signals, 0);
 }
 
 boost::weak_ptr<Route>
diff --git a/libs/ardour/rt_tasklist.cc b/libs/ardour/rt_tasklist.cc
index 70bcab19e8..ccdf96e348 100644
--- a/libs/ardour/rt_tasklist.cc
+++ b/libs/ardour/rt_tasklist.cc
@@ -30,10 +30,10 @@
 using namespace ARDOUR;
 
 RTTaskList::RTTaskList ()
-	: _threads_active (0)
-	, _task_run_sem ("rt_task_run", 0)
+	: _task_run_sem ("rt_task_run", 0)
 	, _task_end_sem ("rt_task_done", 0)
 {
+	g_atomic_int_set (&_threads_active, 0);
 	reset_thread_list ();
 }
 
diff --git a/libs/ardour/selection.cc b/libs/ardour/selection.cc
index cce4007dbf..3c4475872b 100644
--- a/libs/ardour/selection.cc
+++ b/libs/ardour/selection.cc
@@ -45,8 +45,8 @@ CoreSelection::send_selection_change ()
 
 CoreSelection::CoreSelection (Session& s)
 	: session (s)
-	, selection_order (0)
 {
+	g_atomic_int_set (&_selection_order, 0);
 }
 
 CoreSelection::~CoreSelection ()
@@ -246,7 +246,7 @@ CoreSelection::set (StripableList& sl)
 
 		for (StripableList::iterator s = sl.begin(); s != sl.end(); ++s) {
 
-			SelectedStripable ss (*s, no_control, g_atomic_int_add (&selection_order, 1));
+			SelectedStripable ss (*s, no_control, g_atomic_int_add (&_selection_order, 1));
 
 			if (_stripables.insert (ss).second) {
 				DEBUG_TRACE (DEBUG::Selection, string_compose ("set:added %1 to s/c selection\n", (*s)->name()));
@@ -293,7 +293,7 @@ CoreSelection::add (boost::shared_ptr<Stripable> s, boost::shared_ptr<Automation
 	{
 		Glib::Threads::RWLock::WriterLock lm (_lock);
 
-		SelectedStripable ss (s, c, g_atomic_int_add (&selection_order, 1));
+		SelectedStripable ss (s, c, g_atomic_int_add (&_selection_order, 1));
 
 		if (_stripables.insert (ss).second) {
 			DEBUG_TRACE (DEBUG::Selection, string_compose ("added %1/%2 to s/c selection\n", s->name(), c));
@@ -355,7 +355,7 @@ CoreSelection::set (boost::shared_ptr<Stripable> s, boost::shared_ptr<Automation
 	{
 		Glib::Threads::RWLock::WriterLock lm (_lock);
 
-		SelectedStripable ss (s, c, g_atomic_int_add (&selection_order, 1));
+		SelectedStripable ss (s, c, g_atomic_int_add (&_selection_order, 1));
 
 		if (_stripables.size() == 1 && _stripables.find (ss) != _stripables.end()) {
 			return;
diff --git a/libs/ardour/session.cc b/libs/ardour/session.cc
index 81a5874e86..33f9720721 100644
--- a/libs/ardour/session.cc
+++ b/libs/ardour/session.cc
@@ -185,10 +185,7 @@ Session::Session (AudioEngine &eng,
 	, _base_sample_rate (0)
 	, _nominal_sample_rate (0)
 	, _current_sample_rate (0)
-	, _record_status (Disabled)
 	, _transport_sample (0)
-	, _seek_counter (0)
-	, _butler_seek_counter (0)
 	, _session_range_location (0)
 	, _session_range_is_free (true)
 	, _silent (false)
@@ -238,7 +235,6 @@ Session::Session (AudioEngine &eng,
 	, state_tree (0)
 	, state_was_pending (false)
 	, _state_of_the_state (StateOfTheState (CannotSave | InitialConnecting | Loading))
-	, _suspend_save (0)
 	, _save_queued (false)
 	, _save_queued_pending (false)
 	, _last_roll_location (0)
@@ -250,13 +246,11 @@ Session::Session (AudioEngine &eng,
 	, _n_lua_scripts (0)
 	, _butler (new Butler (*this))
 	, _transport_fsm (new TransportFSM (*this))
-	, _post_transport_work (0)
 	, _locations (new Locations (*this))
 	, _ignore_skips_updates (false)
 	, _rt_thread_active (false)
 	, _rt_emit_pending (false)
 	, _ac_thread_active (0)
-	, _latency_recompute_pending (0)
 	, step_speed (0)
 	, outbound_mtc_timecode_frame (0)
 	, next_quarter_frame_to_send (-1)
@@ -280,8 +274,6 @@ Session::Session (AudioEngine &eng,
 	, ltc_timecode_offset (0)
 	, ltc_timecode_negative_offset (false)
 	, midi_control_ui (0)
-	, _punch_or_loop (NoConstraint)
-	, current_usecs_per_track (1000)
 	, _tempo_map (0)
 	, _all_route_group (new RouteGroup (*this, "all"))
 	, routes (new RouteList)
@@ -294,8 +286,6 @@ Session::Session (AudioEngine &eng,
 	, _total_free_4k_blocks (0)
 	, _total_free_4k_blocks_uncertain (false)
 	, no_questions_about_missing_files (false)
-	, _playback_load (0)
-	, _capture_load (0)
 	, _bundles (new BundleList)
 	, _bundle_xml_node (0)
 	, _current_trans (0)
@@ -316,10 +306,7 @@ Session::Session (AudioEngine &eng,
 	, first_file_data_format_reset (true)
 	, first_file_header_format_reset (true)
 	, have_looped (false)
-	, _have_rec_enabled_track (false)
-	, _have_rec_disabled_track (true)
 	, _step_editors (0)
-	, _suspend_timecode_transmission (0)
 	,  _speakers (new Speakers)
 	, _ignore_route_processor_changes (0)
 	, _ignored_a_processor_change (0)
@@ -331,8 +318,23 @@ Session::Session (AudioEngine &eng,
 	, _selection (new CoreSelection (*this))
 	, _global_locate_pending (false)
 	, _had_destructive_tracks (false)
-	, _update_pretty_names (0)
 {
+	g_atomic_int_set (&_suspend_save, 0);
+	g_atomic_int_set (&_playback_load, 0);
+	g_atomic_int_set (&_capture_load, 0);
+	g_atomic_int_set (&_post_transport_work, 0);
+	g_atomic_int_set (&_processing_prohibited, Disabled);
+	g_atomic_int_set (&_record_status, Disabled);
+	g_atomic_int_set (&_punch_or_loop, NoConstraint);
+	g_atomic_int_set (&_current_usecs_per_track, 1000);
+	g_atomic_int_set (&_have_rec_enabled_track, 0);
+	g_atomic_int_set (&_have_rec_disabled_track, 1);
+	g_atomic_int_set (&_latency_recompute_pending, 0);
+	g_atomic_int_set (&_suspend_timecode_transmission, 0);
+	g_atomic_int_set (&_update_pretty_names, 0);
+	g_atomic_int_set (&_seek_counter, 0);
+	g_atomic_int_set (&_butler_seek_counter, 0);
+
 	created_with = string_compose ("%1 %2", PROGRAM_NAME, revision);
 
 	pthread_mutex_init (&_rt_emit_mutex, 0);
@@ -6111,13 +6113,13 @@ Session::add_automation_list(AutomationList *al)
 bool
 Session::have_rec_enabled_track () const
 {
-	return g_atomic_int_get (const_cast<gint*>(&_have_rec_enabled_track)) == 1;
+	return g_atomic_int_get (&_have_rec_enabled_track) == 1;
 }
 
 bool
 Session::have_rec_disabled_track () const
 {
-	return g_atomic_int_get (const_cast<gint*>(&_have_rec_disabled_track)) == 1;
+	return g_atomic_int_get (&_have_rec_disabled_track) == 1;
 }
 
 /** Update the state of our rec-enabled tracks flag */
@@ -7160,7 +7162,6 @@ Session::auto_connect_thread_run ()
 			}
 		}
 
-
 		if (_midi_ports && g_atomic_int_get (&_update_pretty_names)) {
 			boost::shared_ptr<Port> ap = boost::dynamic_pointer_cast<Port> (vkbd_output_port ());
 			if (ap->pretty_name () != _("Virtual Keyboard")) {
diff --git a/libs/ardour/session_process.cc b/libs/ardour/session_process.cc
index 42031c4823..ee1dc2e3fe 100644
--- a/libs/ardour/session_process.cc
+++ b/libs/ardour/session_process.cc
@@ -1361,7 +1361,7 @@ Session::plan_master_strategy (pframes_t nframes, double master_speed, samplepos
 			 * session (so far).
 			 */
 
-			locate_target += wlp + lrintf (ntracks() * sample_rate() * (1.5 * (current_usecs_per_track / 1000000.0)));
+			locate_target += wlp + lrintf (ntracks() * sample_rate() * (1.5 * (g_atomic_int_get (&_current_usecs_per_track) / 1000000.0)));
 
 			DEBUG_TRACE (DEBUG::Slave, string_compose ("After locate-to-catch-master, still too far off (%1). Locate again to %2\n", delta, locate_target));
 
@@ -1419,7 +1419,7 @@ Session::plan_master_strategy (pframes_t nframes, double master_speed, samplepos
 
 		samplepos_t locate_target = master_transport_sample;
 
-		locate_target += wlp + lrintf (ntracks() * sample_rate() * (1.5 * (current_usecs_per_track / 1000000.0)));
+		locate_target += wlp + lrintf (ntracks() * sample_rate() * (1.5 * (g_atomic_int_get (&_current_usecs_per_track) / 1000000.0)));
 
 		DEBUG_TRACE (DEBUG::Slave, string_compose ("request locate to master position %1\n", locate_target));
 
diff --git a/libs/ardour/session_state.cc b/libs/ardour/session_state.cc
index 27a77b8385..7ffddce1f6 100644
--- a/libs/ardour/session_state.cc
+++ b/libs/ardour/session_state.cc
@@ -178,7 +178,7 @@ Session::pre_engine_init (string fullpath)
 	*/
 
 	timerclear (&last_mmc_step);
-	g_atomic_int_set (&processing_prohibited, 0);
+	g_atomic_int_set (&_processing_prohibited, 0);
 	g_atomic_int_set (&_record_status, Disabled);
 	g_atomic_int_set (&_playback_load, 100);
 	g_atomic_int_set (&_capture_load, 100);
diff --git a/libs/ardour/session_transport.cc b/libs/ardour/session_transport.cc
index 9e14f8d7b2..27b71c9478 100644
--- a/libs/ardour/session_transport.cc
+++ b/libs/ardour/session_transport.cc
@@ -1323,8 +1323,8 @@ Session::non_realtime_locate ()
 #ifndef NDEBUG
 		std::cerr << "locate to " << tf << " took " << (end - start) << " usecs for " << nt << " tracks = " << usecs_per_track << " per track\n";
 #endif
-		if (usecs_per_track > g_atomic_int_get (&current_usecs_per_track)) {
-			g_atomic_int_set (&current_usecs_per_track, usecs_per_track);
+		if (usecs_per_track > g_atomic_int_get (&_current_usecs_per_track)) {
+			g_atomic_int_set (&_current_usecs_per_track, usecs_per_track);
 		}
 	}
 
diff --git a/libs/ardour/source.cc b/libs/ardour/source.cc
index cf48501dc1..0e4290fc21 100644
--- a/libs/ardour/source.cc
+++ b/libs/ardour/source.cc
@@ -67,11 +67,12 @@ Source::Source (Session& s, DataType type, const string& name, Flag flags)
 	, _flags(flags)
 	, _natural_position(0)
 	, _have_natural_position (false)
-	, _use_count (0)
 	, _level (0)
 {
+	g_atomic_int_set (&_use_count, 0);
 	_analysed = false;
 	_timestamp = 0;
+
 	fix_writable_flags ();
 }
 
@@ -81,11 +82,11 @@ Source::Source (Session& s, const XMLNode& node)
 	, _flags (Flag (Writable|CanRename))
 	, _natural_position(0)
 	, _have_natural_position (false)
-        , _use_count (0)
 	, _level (0)
 {
-	_timestamp = 0;
+	g_atomic_int_set (&_use_count, 0);
 	_analysed = false;
+	_timestamp = 0;
 
 	if (set_state (node, Stateful::loading_state_version) || _type == DataType::NIL) {
 		throw failed_constructor();
diff --git a/libs/audiographer/audiographer/general/threader.h b/libs/audiographer/audiographer/general/threader.h
index 2ef4099efe..9ef579276e 100644
--- a/libs/audiographer/audiographer/general/threader.h
+++ b/libs/audiographer/audiographer/general/threader.h
@@ -10,6 +10,8 @@
 #include <vector>
 #include <algorithm>
 
+#include "pbd/g_atomic_compat.h"
+
 #include "audiographer/visibility.h"
 #include "audiographer/source.h"
 #include "audiographer/sink.h"
@@ -47,9 +49,10 @@ class /*LIBAUDIOGRAPHER_API*/ Threader : public Source<T>, public Sink<T>
 	  */
 	Threader (Glib::ThreadPool & thread_pool, long wait_timeout_milliseconds = 500)
 	  : thread_pool (thread_pool)
-	  , readers (0)
 	  , wait_timeout (wait_timeout_milliseconds)
-	{ }
+	{
+		g_atomic_int_set (&readers, 0);
+	}
 
 	virtual ~Threader () {}
 
@@ -117,13 +120,14 @@ class /*LIBAUDIOGRAPHER_API*/ Threader : public Source<T>, public Sink<T>
 
 	OutputVec outputs;
 
-	Glib::ThreadPool & thread_pool;
-        Glib::Threads::Mutex wait_mutex;
-        Glib::Threads::Cond  wait_cond;
-	gint        readers;
-	long        wait_timeout;
+	Glib::ThreadPool&    thread_pool;
+	Glib::Threads::Mutex wait_mutex;
+	Glib::Threads::Cond  wait_cond;
+
+	GATOMIC_QUAL gint readers;
+	long         wait_timeout;
 
-        Glib::Threads::Mutex exception_mutex;
+	Glib::Threads::Mutex exception_mutex;
 	boost::shared_ptr<ThreaderException> exception;
 
 };
diff --git a/libs/backends/alsa/alsa_slave.cc b/libs/backends/alsa/alsa_slave.cc
index e439675329..c6327ade2d 100644
--- a/libs/backends/alsa/alsa_slave.cc
+++ b/libs/backends/alsa/alsa_slave.cc
@@ -45,7 +45,6 @@ AlsaAudioSlave::AlsaAudioSlave (
 	, _samples_since_dll_reset (0)
 	, _ratio (1.0)
 	, _slave_speed (1.0)
-	, _draining (1)
 	, _rb_capture (4 * /* AlsaAudioBackend::_max_buffer_size */ 8192 * _pcmi.ncapt ())
 	, _rb_playback (4 * /* AlsaAudioBackend::_max_buffer_size */ 8192 * _pcmi.nplay ())
 	, _samples_per_period (master_samples_per_period)
@@ -53,6 +52,8 @@ AlsaAudioSlave::AlsaAudioSlave (
 	, _play_buff (0)
 	, _src_buff (0)
 {
+	g_atomic_int_set (&_draining, 1);
+
 	if (0 != _pcmi.state()) {
 		return;
 	}
@@ -266,7 +267,7 @@ AlsaAudioSlave::process_thread ()
 				_rb_capture.increment_write_idx (spp * nchn);
 #endif
 			} else {
-				g_atomic_int_set(&_draining, 1);
+				g_atomic_int_set (&_draining, 1);
 			}
 			_pcmi.capt_done (spp);
 
@@ -341,7 +342,7 @@ AlsaAudioSlave::process_thread ()
 		if (xrun && (_pcmi.capt_xrun() > 0 || _pcmi.play_xrun() > 0)) {
 			reset_dll = true;
 			_samples_since_dll_reset = 0;
-			g_atomic_int_set(&_draining, 1);
+			g_atomic_int_set (&_draining, 1);
 		}
 	}
 
@@ -372,7 +373,7 @@ AlsaAudioSlave::cycle_start (double tme, double mst_speed, bool drain)
 	}
 
 	if (drain) {
-		g_atomic_int_set(&_draining, 1);
+		g_atomic_int_set (&_draining, 1);
 		return;
 	}
 
@@ -501,11 +502,11 @@ AlsaAudioSlave::cycle_end ()
 #ifndef NDEBUG
 		std::cerr << "ALSA Slave: Playback Ringbuffer Overflow\n"; // XXX DEBUG
 #endif
-		g_atomic_int_set(&_draining, 1);
+		g_atomic_int_set (&_draining, 1);
 		return;
 	}
 	if (drain_done) {
-		g_atomic_int_set(&_draining, 0);
+		g_atomic_int_set (&_draining, 0);
 	}
 }
 
@@ -513,7 +514,7 @@ void
 AlsaAudioSlave::freewheel (bool onoff)
 {
 	if (onoff) {
-		g_atomic_int_set(&_draining, 1);
+		g_atomic_int_set (&_draining, 1);
 	}
 }
 
diff --git a/libs/backends/alsa/alsa_slave.h b/libs/backends/alsa/alsa_slave.h
index 40c053feb1..1d6e602046 100644
--- a/libs/backends/alsa/alsa_slave.h
+++ b/libs/backends/alsa/alsa_slave.h
@@ -22,6 +22,8 @@
 #include <pthread.h>
 
 #include "pbd/ringbuffer.h"
+#include "pbd/g_atomic_compat.h"
+
 #include "zita-resampler/vresampler.h"
 #include "zita-alsa-pcmi.h"
 
@@ -81,7 +83,8 @@ private:
 	double   _play_latency;
 
 	volatile double _slave_speed;
-	volatile gint   _draining;
+
+	GATOMIC_QUAL gint _draining;
 
 	PBD::RingBuffer<float> _rb_capture;
 	PBD::RingBuffer<float> _rb_playback;
diff --git a/libs/evoral/Event.cc b/libs/evoral/Event.cc
index a2c1cddbc4..c9b33999aa 100644
--- a/libs/evoral/Event.cc
+++ b/libs/evoral/Event.cc
@@ -21,12 +21,13 @@
 
 #include <glib.h>
 
+#include "pbd/g_atomic_compat.h"
 #include "temporal/beats.h"
 #include "evoral/Event.h"
 
 namespace Evoral {
 
-static event_id_t _event_id_counter = 0;
+static GATOMIC_QUAL event_id_t _event_id_counter = 0;
 
 event_id_t
 event_id_counter()
diff --git a/libs/pbd/pbd/atomic_counter.h b/libs/pbd/pbd/atomic_counter.h
index 673ca58126..9aac0c209a 100644
--- a/libs/pbd/pbd/atomic_counter.h
+++ b/libs/pbd/pbd/atomic_counter.h
@@ -20,10 +20,11 @@
 #ifndef PBD_ATOMIC_COUNTER_H
 #define PBD_ATOMIC_COUNTER_H
 
-#include <glib.h>
+#include "pbd/g_atomic_compat.h"
 
 namespace PBD {
 
+#include <glib.h>
 class atomic_counter
 {
 	/**
@@ -35,13 +36,13 @@ class atomic_counter
 public:
 
 	atomic_counter (gint value = 0)
-		:
-			m_value(value)
-	{ }
+	{
+		g_atomic_int_set (&m_value, value);
+	}
 
 	gint get() const
 	{
-		return g_atomic_int_get (const_cast<gint*>(&m_value));
+		return g_atomic_int_get (&m_value);
 	}
 
 	void set (gint new_value)
@@ -88,10 +89,7 @@ public:
 	}
 
 private:
-
-	// Has to be mutable when using the apple version of gcc.
-	gint m_value;
-
+	mutable GATOMIC_QUAL gint m_value;
 };
 
 } // namespace PBD
diff --git a/libs/pbd/pbd/g_atomic_compat.h b/libs/pbd/pbd/g_atomic_compat.h
new file mode 100644
index 0000000000..5b0d167376
--- /dev/null
+++ b/libs/pbd/pbd/g_atomic_compat.h
@@ -0,0 +1,39 @@
+/*
+ * Copyright (C) 2021 Robin Gareus <robin@gareus.org>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#ifndef _PBD_G_ATOMIC_COMPAT_H_
+#define _PBD_G_ATOMIC_COMPAT_H_
+
+/* requires for gint, guint, gpointer */
+#include <glib.h>
+
+/* This is to for g_atomic_* compatibility with glib >= 2.68 and gcc-11
+ *
+ * "While atomic has a volatile qualifier, this is a historical artifact and the pointer passed to it should not be volatile."
+ * (https://developer.gnome.org/glib/2.68/glib-Atomic-Operations.html)
+ *
+ * Older versions of glib and older compilers still expect a volatile qualifier and print
+ * "cast from type 'volatile long int*' to type 'long int*' casts away qualifiers [-Wcast-qual]"
+ */
+#if defined __GNUC__ && __GNUC__ > 10
+#  define GATOMIC_QUAL
+#else
+#  define GATOMIC_QUAL volatile
+#endif
+
+#endif
diff --git a/libs/pbd/pbd/mpmc_queue.h b/libs/pbd/pbd/mpmc_queue.h
index 2c08068e18..69b991e6cf 100644
--- a/libs/pbd/pbd/mpmc_queue.h
+++ b/libs/pbd/pbd/mpmc_queue.h
@@ -23,6 +23,8 @@
 #include <glib.h>
 #include <stdint.h>
 
+#include "pbd/g_atomic_compat.h"
+
 namespace PBD {
 
 /** Lock free multiple producer, multiple consumer queue
@@ -131,15 +133,15 @@ public:
 
 private:
 	struct cell_t {
-		volatile guint _sequence;
-		T              _data;
+		GATOMIC_QUAL guint _sequence;
+		T                  _data;
 	};
 
 	cell_t* _buffer;
 	size_t  _buffer_mask;
 
-	volatile gint _enqueue_pos;
-	volatile gint _dequeue_pos;
+	GATOMIC_QUAL gint _enqueue_pos;
+	GATOMIC_QUAL gint _dequeue_pos;
 };
 
 } /* end namespace */
diff --git a/libs/pbd/pbd/playback_buffer.h b/libs/pbd/pbd/playback_buffer.h
index 8205777cd9..ab2cfe8ca7 100644
--- a/libs/pbd/pbd/playback_buffer.h
+++ b/libs/pbd/pbd/playback_buffer.h
@@ -26,6 +26,7 @@
 
 #include "pbd/libpbd_visibility.h"
 #include "pbd/spinlock.h"
+#include "pbd/g_atomic_compat.h"
 
 namespace PBD {
 
@@ -73,9 +74,9 @@ public:
 	/* called from rt (reader) thread for new buffers */
 	void align_to (PlaybackBuffer const& other) {
 		Glib::Threads::Mutex::Lock lm (_reset_lock);
-		write_idx = other.write_idx;
-		read_idx  = other.read_idx;
-		reserved  = other.reserved;
+		g_atomic_int_set (&read_idx, g_atomic_int_get (&other.read_idx));
+		g_atomic_int_set (&write_idx, g_atomic_int_get (&other.write_idx));
+		g_atomic_int_set (&reserved, g_atomic_int_get (&other.reserved));
 		memset (buf, 0, size * sizeof (T));
 	}
 
@@ -190,9 +191,9 @@ public:
 		}
 	}
 
-	guint read_ptr() const { return read_idx; }
-	guint write_ptr() const { return write_idx; }
-	guint reserved_size() const { return reserved; }
+	guint read_ptr() const { return g_atomic_int_get (&read_idx); }
+	guint write_ptr() const { return g_atomic_int_get (&write_idx); }
+	guint reserved_size() const { return g_atomic_int_get (&reserved); }
 	guint reservation_size() const { return reservation; }
 
 private:
@@ -201,9 +202,9 @@ private:
 	guint size;
 	guint size_mask;
 
-	mutable gint write_idx;
-	mutable gint read_idx;
-	mutable gint reserved;
+	mutable GATOMIC_QUAL gint write_idx;
+	mutable GATOMIC_QUAL gint read_idx;
+	mutable GATOMIC_QUAL gint reserved;
 
 	/* spinlock will be used to update write_idx and reserved in sync */
 	spinlock_t _reservation_lock;
diff --git a/libs/pbd/pbd/rcu.h b/libs/pbd/pbd/rcu.h
index 3e1074d869..86cfcb1131 100644
--- a/libs/pbd/pbd/rcu.h
+++ b/libs/pbd/pbd/rcu.h
@@ -27,6 +27,7 @@
 #include <list>
 
 #include "pbd/libpbd_visibility.h"
+#include "pbd/g_atomic_compat.h"
 
 /** @file rcu.h
  * Define a set of classes to implement Read-Copy-Update.  We do not attempt to define RCU here - use google.
@@ -52,8 +53,8 @@ class /*LIBPBD_API*/ RCUManager
 {
 public:
 	RCUManager (T* new_rcu_value)
-		: _active_reads (0)
 	{
+		g_atomic_int_set (&_active_reads, 0);
 		x.rcu_value = new boost::shared_ptr<T> (new_rcu_value);
 	}
 
@@ -99,8 +100,8 @@ protected:
 	 * evaluate to the same address.
 	 */
 	union {
-		boost::shared_ptr<T>*     rcu_value;
-		mutable volatile gpointer gptr;
+		boost::shared_ptr<T>*         rcu_value;
+		mutable GATOMIC_QUAL gpointer gptr;
 	} x;
 
 	inline bool active_read () const {
@@ -108,7 +109,7 @@ protected:
 	}
 
 private:
-	mutable volatile gint _active_reads;
+	mutable GATOMIC_QUAL gint _active_reads;
 };
 
 /** Serialized RCUManager implements the RCUManager interface. It is based on the
diff --git a/libs/pbd/pbd/ringbuffer.h b/libs/pbd/pbd/ringbuffer.h
index 48d0036933..b834ed4286 100644
--- a/libs/pbd/pbd/ringbuffer.h
+++ b/libs/pbd/pbd/ringbuffer.h
@@ -24,9 +24,9 @@
 #define ringbuffer_h
 
 #include <cstring>
-#include <glib.h>
 
 #include "pbd/libpbd_visibility.h"
+#include "pbd/g_atomic_compat.h"
 
 namespace PBD {
 
@@ -122,9 +122,9 @@ public:
 protected:
 	T *buf;
 	guint size;
-	mutable gint write_idx;
-	mutable gint read_idx;
 	guint size_mask;
+	mutable GATOMIC_QUAL gint write_idx;
+	mutable GATOMIC_QUAL gint read_idx;
 
 private:
 	RingBuffer (RingBuffer const&);
@@ -139,7 +139,7 @@ RingBuffer<T>::read (T *dest, guint cnt)
 	guint n1, n2;
 	guint priv_read_idx;
 
-	priv_read_idx=g_atomic_int_get(&read_idx);
+	priv_read_idx = g_atomic_int_get (&read_idx);
 
 	if ((free_cnt = read_space ()) == 0) {
 		return 0;
@@ -165,7 +165,7 @@ RingBuffer<T>::read (T *dest, guint cnt)
 		priv_read_idx = n2;
 	}
 
-	g_atomic_int_set(&read_idx, priv_read_idx);
+	g_atomic_int_set (&read_idx, priv_read_idx);
 	return to_read;
 }
 
@@ -179,7 +179,7 @@ RingBuffer<T>::write (T const *src, guint cnt)
 	guint n1, n2;
 	guint priv_write_idx;
 
-	priv_write_idx=g_atomic_int_get(&write_idx);
+	priv_write_idx = g_atomic_int_get (&write_idx);
 
 	if ((free_cnt = write_space ()) == 0) {
 		return 0;
@@ -205,7 +205,7 @@ RingBuffer<T>::write (T const *src, guint cnt)
 		priv_write_idx = n2;
 	}
 
-	g_atomic_int_set(&write_idx, priv_write_idx);
+	g_atomic_int_set (&write_idx, priv_write_idx);
 	return to_write;
 }
 
diff --git a/libs/pbd/pbd/ringbufferNPT.h b/libs/pbd/pbd/ringbufferNPT.h
index 174d15e9b9..9e8f352d2d 100644
--- a/libs/pbd/pbd/ringbufferNPT.h
+++ b/libs/pbd/pbd/ringbufferNPT.h
@@ -27,6 +27,7 @@
 #include <glib.h>
 
 #include "pbd/libpbd_visibility.h"
+#include "pbd/g_atomic_compat.h"
 
 namespace PBD {
 
@@ -118,8 +119,8 @@ class /*LIBPBD_API*/ RingBufferNPT
   protected:
 	T *buf;
 	size_t size;
-	mutable gint write_ptr;
-	mutable gint read_ptr;
+	mutable GATOMIC_QUAL gint write_ptr;
+	mutable GATOMIC_QUAL gint read_ptr;
 
 private:
 	RingBufferNPT (RingBufferNPT const&);
@@ -134,7 +135,7 @@ RingBufferNPT<T>::read (T *dest, size_t cnt)
         size_t n1, n2;
         size_t priv_read_ptr;
 
-        priv_read_ptr=g_atomic_int_get(&read_ptr);
+        priv_read_ptr = g_atomic_int_get (&read_ptr);
 
         if ((free_cnt = read_space ()) == 0) {
                 return 0;
@@ -160,7 +161,7 @@ RingBufferNPT<T>::read (T *dest, size_t cnt)
                 priv_read_ptr = n2;
         }
 
-        g_atomic_int_set(&read_ptr, priv_read_ptr);
+        g_atomic_int_set (&read_ptr, priv_read_ptr);
         return to_read;
 }
 
@@ -173,7 +174,7 @@ RingBufferNPT<T>::write (const T *src, size_t cnt)
         size_t n1, n2;
         size_t priv_write_ptr;
 
-        priv_write_ptr=g_atomic_int_get(&write_ptr);
+        priv_write_ptr = g_atomic_int_get (&write_ptr);
 
         if ((free_cnt = write_space ()) == 0) {
                 return 0;
@@ -199,7 +200,7 @@ RingBufferNPT<T>::write (const T *src, size_t cnt)
                 priv_write_ptr = n2;
         }
 
-        g_atomic_int_set(&write_ptr, priv_write_ptr);
+        g_atomic_int_set (&write_ptr, priv_write_ptr);
         return to_write;
 }
 
diff --git a/libs/pbd/pbd/stateful.h b/libs/pbd/pbd/stateful.h
index d7b171b7f5..4041a06208 100644
--- a/libs/pbd/pbd/stateful.h
+++ b/libs/pbd/pbd/stateful.h
@@ -32,6 +32,7 @@
 #include "pbd/xml++.h"
 #include "pbd/property_basics.h"
 #include "pbd/signals.h"
+#include "pbd/g_atomic_compat.h"
 
 class XMLNode;
 
@@ -104,7 +105,7 @@ class LIBPBD_API Stateful {
 	virtual void suspend_property_changes ();
 	virtual void resume_property_changes ();
 
-	bool property_changes_suspended() const { return g_atomic_int_get (const_cast<gint*>(&_stateful_frozen)) > 0; }
+	bool property_changes_suspended() const { return g_atomic_int_get (&_stateful_frozen) > 0; }
 
   protected:
 
@@ -139,8 +140,9 @@ class LIBPBD_API Stateful {
   private:
 	friend struct ForceIDRegeneration;
 	static Glib::Threads::Private<bool> _regenerate_xml_or_string_ids;
-	PBD::ID  _id;
-	gint     _stateful_frozen;
+
+	PBD::ID           _id;
+	GATOMIC_QUAL gint _stateful_frozen;
 
 	static void set_regenerate_xml_and_string_ids_in_this_thread (bool yn);
 };
diff --git a/libs/pbd/stateful.cc b/libs/pbd/stateful.cc
index 1d378da428..4b4cd1b1cd 100644
--- a/libs/pbd/stateful.cc
+++ b/libs/pbd/stateful.cc
@@ -54,8 +54,8 @@ Stateful::Stateful ()
 	: _extra_xml (0)
 	, _instant_xml (0)
 	, _properties (new OwnedPropertyList)
-	, _stateful_frozen (0)
 {
+	g_atomic_int_set (&_stateful_frozen, 0);
 }
 
 Stateful::~Stateful ()
diff --git a/libs/waveview/wave_view_private.cc b/libs/waveview/wave_view_private.cc
index acbec9678a..77a4ae8ba6 100644
--- a/libs/waveview/wave_view_private.cc
+++ b/libs/waveview/wave_view_private.cc
@@ -254,9 +254,9 @@ WaveViewCache::set_image_cache_threshold (uint64_t sz)
 
 /*-------------------------------------------------*/
 
-WaveViewDrawRequest::WaveViewDrawRequest () : stop (0)
+WaveViewDrawRequest::WaveViewDrawRequest ()
 {
-
+	g_atomic_int_set (&_stop, 0);
 }
 
 WaveViewDrawRequest::~WaveViewDrawRequest ()
@@ -407,8 +407,8 @@ WaveViewThreads::stop_threads ()
 
 WaveViewDrawingThread::WaveViewDrawingThread ()
 		: _thread(0)
-		, _quit(0)
 {
+	g_atomic_int_set (&_quit, 0);
 	start ();
 }
 
diff --git a/libs/waveview/waveview/wave_view_private.h b/libs/waveview/waveview/wave_view_private.h
index c17d78a1e5..0b9336ff99 100644
--- a/libs/waveview/waveview/wave_view_private.h
+++ b/libs/waveview/waveview/wave_view_private.h
@@ -202,8 +202,8 @@ public:
 	WaveViewDrawRequest ();
 	~WaveViewDrawRequest ();
 
-	bool stopped() const { return (bool) g_atomic_int_get (const_cast<gint*>(&stop)); }
-	void cancel() { g_atomic_int_set (&stop, 1); }
+	bool stopped() const { return (bool) g_atomic_int_get (&_stop); }
+	void cancel() { g_atomic_int_set (&_stop, 1); }
 	bool finished() { return image->finished(); }
 
 	boost::shared_ptr<WaveViewImage> image;
@@ -213,7 +213,7 @@ public:
 	}
 
 private:
-	gint stop; /* intended for atomic access */
+	GATOMIC_QUAL gint _stop; /* intended for atomic access */
 };
 
 class WaveViewCache;
@@ -320,7 +320,7 @@ private:
 
 private:
 	Glib::Threads::Thread* _thread;
-	gint _quit;
+	GATOMIC_QUAL gint _quit;
 };
 
 class WaveViewThreads {
-- 
2.30.2

