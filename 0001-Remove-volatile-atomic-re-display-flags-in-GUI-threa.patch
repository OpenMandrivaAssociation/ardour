From bf64852fc23ea84b9bfbeec82c28c2e49235742a Mon Sep 17 00:00:00 2001
From: Robin Gareus <robin@gareus.org>
Date: Fri, 19 Mar 2021 03:14:14 +0100
Subject: [PATCH 1/3] Remove volatile/atomic re-display flags in GUI thread

Atomic operations are not needed here, since the GUI
is single threaded.
---
 gtk2_ardour/editor_routes.cc | 32 +++++++++++++++++++-------------
 gtk2_ardour/editor_routes.h  |  5 +++--
 2 files changed, 22 insertions(+), 15 deletions(-)

diff --git a/gtk2_ardour/editor_routes.cc b/gtk2_ardour/editor_routes.cc
index 442cd349fa..cf85dc2d54 100644
--- a/gtk2_ardour/editor_routes.cc
+++ b/gtk2_ardour/editor_routes.cc
@@ -90,8 +90,8 @@ EditorRoutes::EditorRoutes (Editor* e)
 	, _adding_routes (false)
 	, _route_deletion_in_progress (false)
 	, _redisplay_on_resume (false)
+	, _idle_update_queued (false)
 	, _redisplay_active (0)
-	, _queue_tv_update (0)
 	, _menu (0)
 	, old_focus (0)
 	, name_editable (0)
@@ -631,9 +631,8 @@ EditorRoutes::redisplay ()
 		return;
 	}
 
-	// model deprecated g_atomic_int_exchange_and_add(, 1)
-	g_atomic_int_inc(const_cast<gint*>(&_redisplay_active));
-	if (!g_atomic_int_compare_and_exchange (const_cast<gint*>(&_redisplay_active), 1, 1)) {
+	++_redisplay_active;
+	if (_redisplay_active != 1) {
 		/* recursive re-display can happen if redisplay shows/hides a TrackView
 		 * which has children and their display status changes as result.
 		 */
@@ -642,10 +641,11 @@ EditorRoutes::redisplay ()
 
 	redisplay_real ();
 
-	while (!g_atomic_int_compare_and_exchange (const_cast<gint*>(&_redisplay_active), 1, 0)) {
-		g_atomic_int_set(const_cast<gint*>(&_redisplay_active), 1);
+	while (_redisplay_active != 1) {
+		_redisplay_active = 1;
 		redisplay_real ();
 	}
+	_redisplay_active = 0;
 }
 
 void
@@ -944,7 +944,8 @@ EditorRoutes::route_property_changed (const PropertyChange& what_changed, boost:
 void
 EditorRoutes::update_active_display ()
 {
-	if (g_atomic_int_compare_and_exchange (const_cast<gint*>(&_queue_tv_update), 0, 1)) {
+	if (!_idle_update_queued) {
+		_idle_update_queued = true;
 		Glib::signal_idle().connect (sigc::mem_fun (*this, &EditorRoutes::idle_update_mute_rec_solo_etc));
 	}
 }
@@ -1655,7 +1656,8 @@ EditorRoutes::update_input_active_display ()
 void
 EditorRoutes::update_rec_display ()
 {
-	if (g_atomic_int_compare_and_exchange (const_cast<gint*>(&_queue_tv_update), 0, 1)) {
+	if (!_idle_update_queued) {
+		_idle_update_queued = true;
 		Glib::signal_idle().connect (sigc::mem_fun (*this, &EditorRoutes::idle_update_mute_rec_solo_etc));
 	}
 }
@@ -1663,7 +1665,7 @@ EditorRoutes::update_rec_display ()
 bool
 EditorRoutes::idle_update_mute_rec_solo_etc()
 {
-	g_atomic_int_set (const_cast<gint*>(&_queue_tv_update), 0);
+	_idle_update_queued = false;
 	TreeModel::Children rows = _model->children();
 	TreeModel::Children::iterator i;
 
@@ -1709,7 +1711,8 @@ EditorRoutes::idle_update_mute_rec_solo_etc()
 void
 EditorRoutes::update_mute_display ()
 {
-	if (g_atomic_int_compare_and_exchange (const_cast<gint*>(&_queue_tv_update), 0, 1)) {
+	if (!_idle_update_queued) {
+		_idle_update_queued = true;
 		Glib::signal_idle().connect (sigc::mem_fun (*this, &EditorRoutes::idle_update_mute_rec_solo_etc));
 	}
 }
@@ -1717,7 +1720,8 @@ EditorRoutes::update_mute_display ()
 void
 EditorRoutes::update_solo_display ()
 {
-	if (g_atomic_int_compare_and_exchange (const_cast<gint*>(&_queue_tv_update), 0, 1)) {
+	if (!_idle_update_queued) {
+		_idle_update_queued = true;
 		Glib::signal_idle().connect (sigc::mem_fun (*this, &EditorRoutes::idle_update_mute_rec_solo_etc));
 	}
 }
@@ -1725,7 +1729,8 @@ EditorRoutes::update_solo_display ()
 void
 EditorRoutes::update_solo_isolate_display ()
 {
-	if (g_atomic_int_compare_and_exchange (const_cast<gint*>(&_queue_tv_update), 0, 1)) {
+	if (!_idle_update_queued) {
+		_idle_update_queued = true;
 		Glib::signal_idle().connect (sigc::mem_fun (*this, &EditorRoutes::idle_update_mute_rec_solo_etc));
 	}
 }
@@ -1733,7 +1738,8 @@ EditorRoutes::update_solo_isolate_display ()
 void
 EditorRoutes::update_solo_safe_display ()
 {
-	if (g_atomic_int_compare_and_exchange (const_cast<gint*>(&_queue_tv_update), 0, 1)) {
+	if (!_idle_update_queued) {
+		_idle_update_queued = true;
 		Glib::signal_idle().connect (sigc::mem_fun (*this, &EditorRoutes::idle_update_mute_rec_solo_etc));
 	}
 }
diff --git a/gtk2_ardour/editor_routes.h b/gtk2_ardour/editor_routes.h
index 2333538f5f..8f3b603f7a 100644
--- a/gtk2_ardour/editor_routes.h
+++ b/gtk2_ardour/editor_routes.h
@@ -190,8 +190,9 @@ private:
 	bool _adding_routes;
 	bool _route_deletion_in_progress;
 	bool _redisplay_on_resume;
-	volatile gint _redisplay_active;
-	volatile gint _queue_tv_update;
+	bool _idle_update_queued;
+
+	volatile int _redisplay_active;
 
 	Gtk::Menu* _menu;
 	Gtk::Widget* old_focus;
-- 
2.30.2

